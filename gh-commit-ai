#!/usr/bin/env bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
AI_PROVIDER="${AI_PROVIDER:-ollama}"  # Options: ollama, anthropic, openai
OLLAMA_MODEL="${OLLAMA_MODEL:-gemma3:12b}"
OLLAMA_HOST="${OLLAMA_HOST:-http://localhost:11434}"
ANTHROPIC_MODEL="${ANTHROPIC_MODEL:-claude-3-5-sonnet-20241022}"
ANTHROPIC_API_KEY="${ANTHROPIC_API_KEY:-}"
OPENAI_MODEL="${OPENAI_MODEL:-gpt-4o-mini}"
OPENAI_API_KEY="${OPENAI_API_KEY:-}"
DIFF_MAX_LINES="${DIFF_MAX_LINES:-200}"  # Limit diff lines for faster processing
USE_SCOPE="${USE_SCOPE:-true}"  # Enable/disable conventional commit scopes

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo -e "${RED}Error: Not a git repository${NC}"
    exit 1
fi

# Check if there are changes to commit
if git diff --cached --quiet && git diff --quiet; then
    echo -e "${YELLOW}No changes to commit${NC}"
    exit 0
fi

# Get git status and diff
echo -e "${GREEN}Analyzing changes...${NC}"
GIT_STATUS=$(git status --short)

# Get diff stats for overview
GIT_STATS=$(git diff --cached --stat 2>/dev/null || echo "")
if [ -z "$GIT_STATS" ]; then
    GIT_STATS=$(git diff --stat 2>/dev/null || echo "")
fi

# Get diff but limit lines for faster processing
GIT_DIFF=$(git diff --cached 2>/dev/null | head -n "$DIFF_MAX_LINES" || echo "")
if [ -z "$GIT_DIFF" ]; then
    GIT_DIFF=$(git diff 2>/dev/null | head -n "$DIFF_MAX_LINES" || echo "")
fi

# Prepare prompt for Ollama
if [ "$USE_SCOPE" = "true" ]; then
    SCOPE_INSTRUCTION="OUTPUT FORMAT (summary line MUST be first):
<type>(<scope>): <concise summary of all changes below>

The scope should be a short noun describing what part of the codebase changed:
- auth, api, ui, db, cli, docs, config, tests, deps, etc.
- Choose the most relevant scope based on which files/areas changed
- If changes span multiple areas, pick the primary one"
    SCOPE_EXAMPLES="Examples:
- feat(auth): add JWT token validation
- fix(api): resolve timeout in user endpoint
- docs(readme): add installation instructions
- chore(deps): update dependencies"
else
    SCOPE_INSTRUCTION="OUTPUT FORMAT (summary line MUST be first):
<type>: <concise summary of all changes below>"
    SCOPE_EXAMPLES=""
fi

PROMPT="Analyze these git changes and create a commit message.

PROCESS:
1. First, identify all significant changes and list them as bullets
2. Then, synthesize those changes into ONE concise summary line
3. Choose the right type: feat, fix, docs, style, refactor, test, or chore

$SCOPE_INSTRUCTION

- <change 1>
- <change 2>
- <change 3>
- <change 4>

RULES:
- Summary line: max 50 chars, describes the overall purpose
- Use lowercase only (except API, HTTP, JSON, JWT, SQL, ABC-123 tickets)
- Use imperative mood (add/fix not added/fixed)
- The summary should capture the essence of all bullets below it

$SCOPE_EXAMPLES

Files changed:
$GIT_STATUS

Stats:
$GIT_STATS

Diff sample:
$GIT_DIFF

Think: What are all the changes? Then: What's the one-line summary that captures all of them?"

# Escape JSON strings (replace backslash, double quote, newline, carriage return, tab)
escape_json() {
    echo "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\n/\\n/g; s/\r/\\r/g; s/\t/\\t/g' | awk '{printf "%s\\n", $0}' | sed '$ s/\\n$//'
}

# Enforce lowercase on commit message while preserving acronyms and ticket numbers
enforce_lowercase() {
    local message="$1"
    local temp_message="$message"

    # First, protect ticket numbers by replacing them with placeholders
    # Pattern: ABC-123, JIRA-456, etc.
    local ticket_counter=0
    local tickets_file=$(mktemp)

    # Find all ticket numbers and store them
    echo "$message" | grep -oE '[A-Z][A-Z0-9]+-[0-9]+' > "$tickets_file"

    # Replace tickets with placeholders
    while IFS= read -r ticket; do
        if [ -n "$ticket" ]; then
            temp_message=$(echo "$temp_message" | sed "s/$ticket/__TICKET${ticket_counter}__/g")
            ((ticket_counter++))
        fi
    done < "$tickets_file"

    # Convert entire message to lowercase
    temp_message=$(echo "$temp_message" | tr '[:upper:]' '[:lower:]')

    # Restore ticket numbers
    ticket_counter=0
    while IFS= read -r ticket; do
        if [ -n "$ticket" ]; then
            temp_message=$(echo "$temp_message" | sed "s/__ticket${ticket_counter}__/$ticket/g")
            ((ticket_counter++))
        fi
    done < "$tickets_file"

    rm -f "$tickets_file"

    # Restore common acronyms (case-insensitive search and replace)
    local acronyms="API HTTP HTTPS JSON XML SQL JWT OAuth REST CLI UI UX CSS HTML JS TS URL URI PDF CSV IDE SDK CI CD AWS GCP DNS SSL TLS SSH FTP SMTP TCP UDP IP DOM npm NPM README TODO FIXME"

    for acronym in $acronyms; do
        local lowercase_acronym=$(echo "$acronym" | tr '[:upper:]' '[:lower:]')
        # Use word boundaries to avoid partial matches
        temp_message=$(echo "$temp_message" | sed "s/\b$lowercase_acronym\b/$acronym/g")
    done

    echo "$temp_message"
}

# Call Ollama API
call_ollama() {
    local prompt="$1"
    echo -e "${GREEN}Generating commit message with $OLLAMA_MODEL...${NC}"

    local model_escaped=$(escape_json "$OLLAMA_MODEL")
    local prompt_escaped=$(escape_json "$prompt")
    local json_payload=$(printf '{"model":"%s","prompt":"%s","stream":false}' "$model_escaped" "$prompt_escaped")

    local response=$(curl -s -X POST "$OLLAMA_HOST/api/generate" \
        -H "Content-Type: application/json" \
        -d "$json_payload")

    # Extract commit message from response
    echo "$response" | grep -o '"response":"[^"]*"' | sed 's/"response":"//;s/"$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
}

# Call Anthropic API
call_anthropic() {
    local prompt="$1"

    if [ -z "$ANTHROPIC_API_KEY" ]; then
        echo -e "${RED}Error: ANTHROPIC_API_KEY is not set${NC}"
        exit 1
    fi

    echo -e "${GREEN}Generating commit message with $ANTHROPIC_MODEL...${NC}"

    local prompt_escaped=$(escape_json "$prompt")
    local json_payload=$(printf '{"model":"%s","max_tokens":1024,"messages":[{"role":"user","content":"%s"}]}' "$ANTHROPIC_MODEL" "$prompt_escaped")

    local response=$(curl -s -X POST "https://api.anthropic.com/v1/messages" \
        -H "Content-Type: application/json" \
        -H "x-api-key: $ANTHROPIC_API_KEY" \
        -H "anthropic-version: 2023-06-01" \
        -d "$json_payload")

    # Extract commit message from response
    # Anthropic returns: {"content":[{"text":"...","type":"text"}],...}
    echo "$response" | grep -o '"text":"[^"]*"' | head -1 | sed 's/"text":"//;s/"$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
}

# Call OpenAI API
call_openai() {
    local prompt="$1"

    if [ -z "$OPENAI_API_KEY" ]; then
        echo -e "${RED}Error: OPENAI_API_KEY is not set${NC}"
        exit 1
    fi

    echo -e "${GREEN}Generating commit message with $OPENAI_MODEL...${NC}"

    local prompt_escaped=$(escape_json "$prompt")
    local json_payload=$(printf '{"model":"%s","messages":[{"role":"user","content":"%s"}],"temperature":0.7}' "$OPENAI_MODEL" "$prompt_escaped")

    local response=$(curl -s -X POST "https://api.openai.com/v1/chat/completions" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $OPENAI_API_KEY" \
        -d "$json_payload")

    # Extract commit message from response
    # OpenAI returns: {"choices":[{"message":{"content":"..."},...}],...}
    echo "$response" | grep -o '"content":"[^"]*"' | head -1 | sed 's/"content":"//;s/"$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
}

# Call the appropriate AI provider
case "$AI_PROVIDER" in
    ollama)
        COMMIT_MSG=$(call_ollama "$PROMPT")
        ;;
    anthropic)
        COMMIT_MSG=$(call_anthropic "$PROMPT")
        ;;
    openai)
        COMMIT_MSG=$(call_openai "$PROMPT")
        ;;
    *)
        echo -e "${RED}Error: Unknown AI provider '$AI_PROVIDER'${NC}"
        echo "Supported providers: ollama, anthropic, openai"
        exit 1
        ;;
esac

if [ -z "$COMMIT_MSG" ] || [ "$COMMIT_MSG" = "null" ]; then
    echo -e "${RED}Error: Failed to generate commit message${NC}"
    echo "Please check your API configuration and try again."
    exit 1
fi

# Enforce lowercase (preserving acronyms and ticket numbers)
COMMIT_MSG=$(enforce_lowercase "$COMMIT_MSG")

# Show the generated commit message
echo -e "\n${GREEN}Generated commit message:${NC}"
echo -e "${YELLOW}$COMMIT_MSG${NC}\n"

# Ask for confirmation
read -p "Use this commit message? (y/n/e to edit): " -n 1 -r
echo

if [[ $REPLY =~ ^[Yy]$ ]]; then
    # Stage all changes if nothing is staged
    if git diff --cached --quiet; then
        echo -e "${GREEN}Staging all changes...${NC}"
        git add -A
    fi

    # Commit with the generated message
    git commit -m "$COMMIT_MSG"
    echo -e "${GREEN}✓ Committed successfully!${NC}"
elif [[ $REPLY =~ ^[Ee]$ ]]; then
    # Allow user to edit the message
    git commit -e -m "$COMMIT_MSG"
    echo -e "${GREEN}✓ Committed with edited message!${NC}"
else
    echo -e "${YELLOW}Commit cancelled${NC}"
    exit 0
fi
