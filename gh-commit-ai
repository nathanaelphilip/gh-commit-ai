#!/usr/bin/env bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
AI_PROVIDER="${AI_PROVIDER:-ollama}"  # Options: ollama, anthropic, openai
OLLAMA_MODEL="${OLLAMA_MODEL:-gemma3:12b}"
OLLAMA_HOST="${OLLAMA_HOST:-http://localhost:11434}"
ANTHROPIC_MODEL="${ANTHROPIC_MODEL:-claude-3-5-sonnet-20241022}"
ANTHROPIC_API_KEY="${ANTHROPIC_API_KEY:-}"
OPENAI_MODEL="${OPENAI_MODEL:-gpt-4o-mini}"
OPENAI_API_KEY="${OPENAI_API_KEY:-}"
DIFF_MAX_LINES="${DIFF_MAX_LINES:-200}"  # Limit diff lines for faster processing
USE_SCOPE="${USE_SCOPE:-false}"  # Enable/disable conventional commit scopes

# Parse command-line arguments
DRY_RUN=false
PREVIEW=false
AMEND=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --preview)
            PREVIEW=true
            shift
            ;;
        --amend)
            AMEND=true
            shift
            ;;
        --help|-h)
            echo "gh-commit-ai - AI-powered git commit message generator"
            echo ""
            echo "Usage: gh commit-ai [options]"
            echo ""
            echo "Options:"
            echo "  --dry-run    Generate commit message without committing"
            echo "  --preview    Generate and display message, then exit"
            echo "  --amend      Regenerate message for last commit"
            echo "  --help, -h   Show this help message"
            echo ""
            echo "Environment Variables:"
            echo "  AI_PROVIDER      AI provider to use (ollama, anthropic, openai)"
            echo "  USE_SCOPE        Enable/disable scopes (true/false)"
            echo "  DIFF_MAX_LINES   Maximum diff lines to send to AI"
            echo ""
            echo "Examples:"
            echo "  gh commit-ai"
            echo "  gh commit-ai --dry-run"
            echo "  gh commit-ai --preview"
            echo "  gh commit-ai --amend"
            echo "  USE_SCOPE=false gh commit-ai"
            exit 0
            ;;
        *)
            echo -e "${RED}Error: Unknown option $1${NC}"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo -e "${RED}Error: Not a git repository${NC}"
    exit 1
fi

# Handle amend mode differently
if [ "$AMEND" = true ]; then
    # Check if there's at least one commit
    if ! git rev-parse HEAD >/dev/null 2>&1; then
        echo -e "${RED}Error: No commits to amend${NC}"
        exit 1
    fi

    echo -e "${GREEN}Analyzing last commit...${NC}"

    # Get the changes from the last commit
    GIT_STATUS=$(git show --name-status --pretty=format:"" HEAD | grep -E '^[AMDRC]' | awk '{print $1 " " $2}')
    GIT_STATS=$(git show --stat HEAD | tail -n +2)
    GIT_DIFF=$(git show HEAD | head -n "$DIFF_MAX_LINES")
else
    # Check if there are changes to commit
    if git diff --cached --quiet && git diff --quiet; then
        echo -e "${YELLOW}No changes to commit${NC}"
        exit 0
    fi

    # Get git status and diff
    echo -e "${GREEN}Analyzing changes...${NC}"
    GIT_STATUS=$(git status --short)

    # Get diff stats for overview
    GIT_STATS=$(git diff --cached --stat 2>/dev/null || echo "")
    if [ -z "$GIT_STATS" ]; then
        GIT_STATS=$(git diff --stat 2>/dev/null || echo "")
    fi

    # Get diff but limit lines for faster processing
    GIT_DIFF=$(git diff --cached 2>/dev/null | head -n "$DIFF_MAX_LINES" || echo "")
    if [ -z "$GIT_DIFF" ]; then
        GIT_DIFF=$(git diff 2>/dev/null | head -n "$DIFF_MAX_LINES" || echo "")
    fi
fi

# Get current branch name
BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")

# Extract ticket number from branch name (e.g., feature/ABC-123-description → ABC-123)
TICKET_NUMBER=""
if [ -n "$BRANCH_NAME" ]; then
    TICKET_NUMBER=$(echo "$BRANCH_NAME" | grep -oE '[A-Z][A-Z0-9]+-[0-9]+' | head -1)
fi

# Detect suggested type from branch name
SUGGESTED_TYPE=""
if [ -n "$BRANCH_NAME" ]; then
    case "$BRANCH_NAME" in
        feat/*|feature/*) SUGGESTED_TYPE="feat" ;;
        fix/*|bugfix/*|hotfix/*) SUGGESTED_TYPE="fix" ;;
        docs/*|doc/*) SUGGESTED_TYPE="docs" ;;
        style/*) SUGGESTED_TYPE="style" ;;
        refactor/*) SUGGESTED_TYPE="refactor" ;;
        test/*|tests/*) SUGGESTED_TYPE="test" ;;
        chore/*) SUGGESTED_TYPE="chore" ;;
    esac
fi

# Prepare branch context
BRANCH_CONTEXT="Branch context:
- Branch name: $BRANCH_NAME"

if [ -n "$TICKET_NUMBER" ]; then
    BRANCH_CONTEXT="$BRANCH_CONTEXT
- Ticket number: $TICKET_NUMBER (include this in your commit message)"
fi

if [ -n "$SUGGESTED_TYPE" ]; then
    BRANCH_CONTEXT="$BRANCH_CONTEXT
- Suggested type: $SUGGESTED_TYPE (based on branch name)"
fi

# Prepare closing instruction
CLOSING_INSTRUCTION="Think: What are all the changes? Then: What's the one-line summary that captures all of them?"
if [ -n "$TICKET_NUMBER" ]; then
    CLOSING_INSTRUCTION="$CLOSING_INSTRUCTION Include ticket $TICKET_NUMBER in the summary."
fi

# Prepare prompt for Ollama
if [ "$USE_SCOPE" = "true" ]; then
    SCOPE_INSTRUCTION="OUTPUT FORMAT (summary line MUST be first):
<type>(<scope>): <concise summary of all changes below>

The scope should be a short noun describing what part of the codebase changed:
- auth, api, ui, db, cli, docs, config, tests, deps, etc.
- Choose the most relevant scope based on which files/areas changed
- If changes span multiple areas, pick the primary one"
    SCOPE_EXAMPLES="Examples:
- feat(auth): add JWT token validation
- fix(api): resolve timeout in user endpoint
- docs(readme): add installation instructions
- chore(deps): update dependencies"
else
    SCOPE_INSTRUCTION="OUTPUT FORMAT (summary line MUST be first):
<type>: <concise summary of all changes below>"
    SCOPE_EXAMPLES=""
fi

PROMPT="Analyze these git changes and create a commit message.

PROCESS:
1. First, identify all significant changes and list them as bullets
2. Then, synthesize those changes into ONE concise summary line
3. Choose the right type: feat, fix, docs, style, refactor, test, or chore

$SCOPE_INSTRUCTION

- <change 1>
- <change 2>
- <change 3>
- <change 4>

RULES:
- Summary line: max 50 chars, describes the overall purpose
- Use lowercase only (except API, HTTP, JSON, JWT, SQL, ABC-123 tickets)
- Use imperative mood (add/fix not added/fixed)
- The summary should capture the essence of all bullets below it

$SCOPE_EXAMPLES

$BRANCH_CONTEXT

Files changed:
$GIT_STATUS

Stats:
$GIT_STATS

Diff sample:
$GIT_DIFF

$CLOSING_INSTRUCTION"

# Escape JSON strings (replace backslash, double quote, newline, carriage return, tab)
escape_json() {
    echo "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\n/\\n/g; s/\r/\\r/g; s/\t/\\t/g' | awk '{printf "%s\\n", $0}' | sed '$ s/\\n$//'
}

# Enforce lowercase on commit message while preserving acronyms and ticket numbers
enforce_lowercase() {
    local message="$1"
    local temp_message="$message"

    # First, protect ticket numbers by replacing them with placeholders
    # Pattern: ABC-123, JIRA-456, etc.
    local ticket_counter=0
    local tickets_file=$(mktemp)

    # Find all ticket numbers and store them
    echo "$message" | grep -oE '[A-Z][A-Z0-9]+-[0-9]+' > "$tickets_file"

    # Replace tickets with placeholders
    while IFS= read -r ticket; do
        if [ -n "$ticket" ]; then
            temp_message=$(echo "$temp_message" | sed "s/$ticket/__TICKET${ticket_counter}__/g")
            ((ticket_counter++))
        fi
    done < "$tickets_file"

    # Convert entire message to lowercase
    temp_message=$(echo "$temp_message" | tr '[:upper:]' '[:lower:]')

    # Restore ticket numbers
    ticket_counter=0
    while IFS= read -r ticket; do
        if [ -n "$ticket" ]; then
            temp_message=$(echo "$temp_message" | sed "s/__ticket${ticket_counter}__/$ticket/g")
            ((ticket_counter++))
        fi
    done < "$tickets_file"

    rm -f "$tickets_file"

    # Restore common acronyms (case-insensitive search and replace)
    local acronyms="API HTTP HTTPS JSON XML SQL JWT OAuth REST CLI UI UX CSS HTML JS TS URL URI PDF CSV IDE SDK CI CD AWS GCP DNS SSL TLS SSH FTP SMTP TCP UDP IP DOM npm NPM README TODO FIXME"

    for acronym in $acronyms; do
        local lowercase_acronym=$(echo "$acronym" | tr '[:upper:]' '[:lower:]')
        # Use word boundaries to avoid partial matches
        temp_message=$(echo "$temp_message" | sed "s/\b$lowercase_acronym\b/$acronym/g")
    done

    echo "$temp_message"
}

# Call Ollama API
call_ollama() {
    local prompt="$1"
    echo -e "${GREEN}Generating commit message with $OLLAMA_MODEL...${NC}"

    local model_escaped=$(escape_json "$OLLAMA_MODEL")
    local prompt_escaped=$(escape_json "$prompt")
    local json_payload=$(printf '{"model":"%s","prompt":"%s","stream":false}' "$model_escaped" "$prompt_escaped")

    local response=$(curl -s -X POST "$OLLAMA_HOST/api/generate" \
        -H "Content-Type: application/json" \
        -d "$json_payload")

    # Extract commit message from response
    echo "$response" | grep -o '"response":"[^"]*"' | sed 's/"response":"//;s/"$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
}

# Call Anthropic API
call_anthropic() {
    local prompt="$1"

    if [ -z "$ANTHROPIC_API_KEY" ]; then
        echo -e "${RED}Error: ANTHROPIC_API_KEY is not set${NC}"
        exit 1
    fi

    echo -e "${GREEN}Generating commit message with $ANTHROPIC_MODEL...${NC}"

    local prompt_escaped=$(escape_json "$prompt")
    local json_payload=$(printf '{"model":"%s","max_tokens":1024,"messages":[{"role":"user","content":"%s"}]}' "$ANTHROPIC_MODEL" "$prompt_escaped")

    local response=$(curl -s -X POST "https://api.anthropic.com/v1/messages" \
        -H "Content-Type: application/json" \
        -H "x-api-key: $ANTHROPIC_API_KEY" \
        -H "anthropic-version: 2023-06-01" \
        -d "$json_payload")

    # Extract commit message from response
    # Anthropic returns: {"content":[{"text":"...","type":"text"}],...}
    echo "$response" | grep -o '"text":"[^"]*"' | head -1 | sed 's/"text":"//;s/"$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
}

# Call OpenAI API
call_openai() {
    local prompt="$1"

    if [ -z "$OPENAI_API_KEY" ]; then
        echo -e "${RED}Error: OPENAI_API_KEY is not set${NC}"
        exit 1
    fi

    echo -e "${GREEN}Generating commit message with $OPENAI_MODEL...${NC}"

    local prompt_escaped=$(escape_json "$prompt")
    local json_payload=$(printf '{"model":"%s","messages":[{"role":"user","content":"%s"}],"temperature":0.7}' "$OPENAI_MODEL" "$prompt_escaped")

    local response=$(curl -s -X POST "https://api.openai.com/v1/chat/completions" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $OPENAI_API_KEY" \
        -d "$json_payload")

    # Extract commit message from response
    # OpenAI returns: {"choices":[{"message":{"content":"..."},...}],...}
    echo "$response" | grep -o '"content":"[^"]*"' | head -1 | sed 's/"content":"//;s/"$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
}

# Call the appropriate AI provider
case "$AI_PROVIDER" in
    ollama)
        COMMIT_MSG=$(call_ollama "$PROMPT")
        ;;
    anthropic)
        COMMIT_MSG=$(call_anthropic "$PROMPT")
        ;;
    openai)
        COMMIT_MSG=$(call_openai "$PROMPT")
        ;;
    *)
        echo -e "${RED}Error: Unknown AI provider '$AI_PROVIDER'${NC}"
        echo "Supported providers: ollama, anthropic, openai"
        exit 1
        ;;
esac

if [ -z "$COMMIT_MSG" ] || [ "$COMMIT_MSG" = "null" ]; then
    echo -e "${RED}Error: Failed to generate commit message${NC}"
    echo "Please check your API configuration and try again."
    exit 1
fi

# Enforce lowercase (preserving acronyms and ticket numbers)
COMMIT_MSG=$(enforce_lowercase "$COMMIT_MSG")

# Show the generated commit message
echo -e "\n${GREEN}Generated commit message:${NC}"
echo -e "${YELLOW}$COMMIT_MSG${NC}\n"

# Handle preview mode - just show and exit
if [ "$PREVIEW" = true ]; then
    exit 0
fi

# Handle dry-run mode - ask if user wants to save to file
if [ "$DRY_RUN" = true ]; then
    read -p "Save to file? (y/n): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        COMMIT_FILE=".git/COMMIT_MSG_$(date +%s)"
        echo "$COMMIT_MSG" > "$COMMIT_FILE"
        echo -e "${GREEN}✓ Saved to $COMMIT_FILE${NC}"
    else
        echo -e "${YELLOW}Message not saved${NC}"
    fi
    exit 0
fi

# Ask for confirmation
read -p "Use this commit message? (y/n/e to edit): " -n 1 -r
echo

if [[ $REPLY =~ ^[Yy]$ ]]; then
    if [ "$AMEND" = true ]; then
        # Amend the last commit with new message
        git commit --amend -m "$COMMIT_MSG"
        echo -e "${GREEN}✓ Amended commit successfully!${NC}"
    else
        # Stage all changes if nothing is staged
        if git diff --cached --quiet; then
            echo -e "${GREEN}Staging all changes...${NC}"
            git add -A
        fi

        # Commit with the generated message
        git commit -m "$COMMIT_MSG"
        echo -e "${GREEN}✓ Committed successfully!${NC}"
    fi
elif [[ $REPLY =~ ^[Ee]$ ]]; then
    # Allow user to edit the message
    if [ "$AMEND" = true ]; then
        git commit --amend -e -m "$COMMIT_MSG"
        echo -e "${GREEN}✓ Amended commit with edited message!${NC}"
    else
        git commit -e -m "$COMMIT_MSG"
        echo -e "${GREEN}✓ Committed with edited message!${NC}"
    fi
else
    echo -e "${YELLOW}Commit cancelled${NC}"
    exit 0
fi
