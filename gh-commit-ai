#!/usr/bin/env bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Simple YAML parser (supports only simple key: value pairs)
parse_yaml_config() {
    local config_file="$1"

    if [ ! -f "$config_file" ]; then
        return
    fi

    while IFS=: read -r key value; do
        # Skip comments and empty lines
        [[ "$key" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$key" ]] && continue

        # Trim whitespace
        key=$(echo "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        value=$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

        # Remove quotes from value
        value=$(echo "$value" | sed 's/^["'\'']\|["'\'']$//g')

        # Only set if not already set by environment variable
        case "$key" in
            ai_provider|AI_PROVIDER)
                CONFIG_AI_PROVIDER="${CONFIG_AI_PROVIDER:-$value}"
                ;;
            ollama_model|OLLAMA_MODEL)
                CONFIG_OLLAMA_MODEL="${CONFIG_OLLAMA_MODEL:-$value}"
                ;;
            ollama_host|OLLAMA_HOST)
                CONFIG_OLLAMA_HOST="${CONFIG_OLLAMA_HOST:-$value}"
                ;;
            anthropic_model|ANTHROPIC_MODEL)
                CONFIG_ANTHROPIC_MODEL="${CONFIG_ANTHROPIC_MODEL:-$value}"
                ;;
            openai_model|OPENAI_MODEL)
                CONFIG_OPENAI_MODEL="${CONFIG_OPENAI_MODEL:-$value}"
                ;;
            use_scope|USE_SCOPE)
                CONFIG_USE_SCOPE="${CONFIG_USE_SCOPE:-$value}"
                ;;
            diff_max_lines|DIFF_MAX_LINES)
                CONFIG_DIFF_MAX_LINES="${CONFIG_DIFF_MAX_LINES:-$value}"
                ;;
            learn_from_history|LEARN_FROM_HISTORY)
                CONFIG_LEARN_FROM_HISTORY="${CONFIG_LEARN_FROM_HISTORY:-$value}"
                ;;
        esac
    done < "$config_file"
}

# Load configuration from files (global then local)
# Global config (in user's home directory)
if [ -f "$HOME/.gh-commit-ai.yml" ]; then
    parse_yaml_config "$HOME/.gh-commit-ai.yml"
fi

# Local config (in current repository)
if [ -f ".gh-commit-ai.yml" ]; then
    parse_yaml_config ".gh-commit-ai.yml"
fi

# Configuration (priority: env vars > local config > global config > defaults)
AI_PROVIDER="${AI_PROVIDER:-${CONFIG_AI_PROVIDER:-ollama}}"  # Options: ollama, anthropic, openai
OLLAMA_MODEL="${OLLAMA_MODEL:-${CONFIG_OLLAMA_MODEL:-gemma3:12b}}"
OLLAMA_HOST="${OLLAMA_HOST:-${CONFIG_OLLAMA_HOST:-http://localhost:11434}}"
ANTHROPIC_MODEL="${ANTHROPIC_MODEL:-${CONFIG_ANTHROPIC_MODEL:-claude-3-5-sonnet-20241022}}"
ANTHROPIC_API_KEY="${ANTHROPIC_API_KEY:-}"
OPENAI_MODEL="${OPENAI_MODEL:-${CONFIG_OPENAI_MODEL:-gpt-4o-mini}}"
OPENAI_API_KEY="${OPENAI_API_KEY:-}"
DIFF_MAX_LINES="${DIFF_MAX_LINES:-${CONFIG_DIFF_MAX_LINES:-200}}"  # Limit diff lines for faster processing
USE_SCOPE="${USE_SCOPE:-${CONFIG_USE_SCOPE:-false}}"  # Enable/disable conventional commit scopes
LEARN_FROM_HISTORY="${LEARN_FROM_HISTORY:-${CONFIG_LEARN_FROM_HISTORY:-true}}"  # Enable/disable learning from commit history

# Parse command-line arguments
DRY_RUN=false
PREVIEW=false
AMEND=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --preview)
            PREVIEW=true
            shift
            ;;
        --amend)
            AMEND=true
            shift
            ;;
        --help|-h)
            echo "gh-commit-ai - AI-powered git commit message generator"
            echo ""
            echo "Usage: gh commit-ai [options]"
            echo ""
            echo "Options:"
            echo "  --dry-run    Generate commit message without committing"
            echo "  --preview    Generate and display message, then exit"
            echo "  --amend      Regenerate message for last commit"
            echo "  --help, -h   Show this help message"
            echo ""
            echo "Interactive Options (when reviewing commit message):"
            echo "  y - Accept and commit"
            echo "  n - Cancel"
            echo "  e - Edit in your default editor"
            echo "  i - Interactive editing (modify summary/bullets)"
            echo ""
            echo "Environment Variables:"
            echo "  AI_PROVIDER      AI provider to use (ollama, anthropic, openai)"
            echo "  USE_SCOPE        Enable/disable scopes (true/false)"
            echo "  DIFF_MAX_LINES   Maximum diff lines to send to AI"
            echo ""
            echo "Configuration Files:"
            echo "  .gh-commit-ai.yml       Local config (repo root)"
            echo "  ~/.gh-commit-ai.yml     Global config"
            echo ""
            echo "Examples:"
            echo "  gh commit-ai"
            echo "  gh commit-ai --dry-run"
            echo "  gh commit-ai --preview"
            echo "  gh commit-ai --amend"
            echo "  USE_SCOPE=false gh commit-ai"
            exit 0
            ;;
        *)
            echo -e "${RED}Error: Unknown option $1${NC}"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo -e "${RED}Error: Not a git repository${NC}"
    exit 1
fi

# Handle amend mode differently
if [ "$AMEND" = true ]; then
    # Check if there's at least one commit
    if ! git rev-parse HEAD >/dev/null 2>&1; then
        echo -e "${RED}Error: No commits to amend${NC}"
        exit 1
    fi

    echo -e "${GREEN}Analyzing last commit...${NC}"

    # Get the changes from the last commit
    GIT_STATUS=$(git show --name-status --pretty=format:"" HEAD | grep -E '^[AMDRC]' | awk '{print $1 " " $2}')
    GIT_STATS=$(git show --stat HEAD | tail -n +2)
    GIT_DIFF=$(git show HEAD | head -n "$DIFF_MAX_LINES")
else
    # Check if there are changes to commit
    if git diff --cached --quiet && git diff --quiet; then
        echo -e "${YELLOW}No changes to commit${NC}"
        exit 0
    fi

    # Get git status and diff
    echo -e "${GREEN}Analyzing changes...${NC}"
    GIT_STATUS=$(git status --short)

    # Get diff stats for overview
    GIT_STATS=$(git diff --cached --stat 2>/dev/null || echo "")
    if [ -z "$GIT_STATS" ]; then
        GIT_STATS=$(git diff --stat 2>/dev/null || echo "")
    fi

    # Get diff but limit lines for faster processing
    GIT_DIFF=$(git diff --cached 2>/dev/null | head -n "$DIFF_MAX_LINES" || echo "")
    if [ -z "$GIT_DIFF" ]; then
        GIT_DIFF=$(git diff 2>/dev/null | head -n "$DIFF_MAX_LINES" || echo "")
    fi
fi

# Get current branch name
BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")

# Extract ticket number from branch name (e.g., feature/ABC-123-description → ABC-123)
TICKET_NUMBER=""
if [ -n "$BRANCH_NAME" ]; then
    TICKET_NUMBER=$(echo "$BRANCH_NAME" | grep -oE '[A-Z][A-Z0-9]+-[0-9]+' | head -1)
fi

# Detect suggested type from branch name
SUGGESTED_TYPE=""
if [ -n "$BRANCH_NAME" ]; then
    case "$BRANCH_NAME" in
        feat/*|feature/*) SUGGESTED_TYPE="feat" ;;
        fix/*|bugfix/*|hotfix/*) SUGGESTED_TYPE="fix" ;;
        docs/*|doc/*) SUGGESTED_TYPE="docs" ;;
        style/*) SUGGESTED_TYPE="style" ;;
        refactor/*) SUGGESTED_TYPE="refactor" ;;
        test/*|tests/*) SUGGESTED_TYPE="test" ;;
        chore/*) SUGGESTED_TYPE="chore" ;;
    esac
fi

# Smart type detection based on changed files and content
detect_smart_type() {
    local files="$1"
    local diff="$2"

    # Get list of changed files (extract filenames from git status)
    local changed_files=$(echo "$files" | awk '{print $NF}')

    # Count different file types
    local doc_count=0
    local test_count=0
    local config_count=0
    local code_count=0
    local total_count=0

    while IFS= read -r file; do
        [ -z "$file" ] && continue
        total_count=$((total_count + 1))

        # Check for documentation files
        if [[ "$file" =~ \.(md|txt|rst|adoc)$ ]] || [[ "$file" =~ ^docs?/ ]] || [[ "$file" =~ ^documentation/ ]] || [[ "$file" =~ README|CHANGELOG|LICENSE ]]; then
            doc_count=$((doc_count + 1))
        # Check for test files
        elif [[ "$file" =~ ^tests?/ ]] || [[ "$file" =~ \.(test|spec)\. ]] || [[ "$file" =~ [_-](test|spec)\. ]] || [[ "$file" =~ __tests?__/ ]]; then
            test_count=$((test_count + 1))
        # Check for config files
        elif [[ "$file" =~ \.(json|ya?ml|toml|ini|conf|config)$ ]] || [[ "$file" =~ ^\..*rc$ ]] || [[ "$file" =~ package\.json|setup\.py|Cargo\.toml|go\.mod ]]; then
            config_count=$((config_count + 1))
        else
            code_count=$((code_count + 1))
        fi
    done <<< "$changed_files"

    # Return early if no files detected
    [ $total_count -eq 0 ] && return

    # If only docs changed, suggest docs
    if [ $doc_count -gt 0 ] && [ $test_count -eq 0 ] && [ $code_count -eq 0 ]; then
        echo "docs"
        return
    fi

    # If only tests changed, suggest test
    if [ $test_count -gt 0 ] && [ $doc_count -eq 0 ] && [ $code_count -eq 0 ]; then
        echo "test"
        return
    fi

    # Check for version bumps in config files
    if [ $config_count -gt 0 ]; then
        if echo "$diff" | grep -qE '^\+.*"version".*:' || \
           echo "$diff" | grep -qE '^\+.*version\s*='; then
            echo "chore"
            return
        fi
    fi

    # Check for bug-related keywords in diff
    if echo "$diff" | grep -qiE '^\+.*(fix|bug|issue|error|crash|problem|broken|incorrect|wrong)'; then
        echo "fix"
        return
    fi

    # No strong signal detected
    echo ""
}

# Run smart type detection
SMART_TYPE=$(detect_smart_type "$GIT_STATUS" "$GIT_DIFF")

# Track where the suggestion came from for better prompting
TYPE_SOURCE=""
if [ -n "$SUGGESTED_TYPE" ]; then
    TYPE_SOURCE="branch name"
fi

# Smart type detection can override if branch gives no suggestion
if [ -z "$SUGGESTED_TYPE" ] && [ -n "$SMART_TYPE" ]; then
    SUGGESTED_TYPE="$SMART_TYPE"
    TYPE_SOURCE="file analysis"
elif [ -n "$SMART_TYPE" ] && [ "$SMART_TYPE" != "$SUGGESTED_TYPE" ]; then
    # Both exist but differ - mention both in context
    TYPE_SOURCE="branch name (smart detection also suggests: $SMART_TYPE)"
fi

# Detect breaking changes
detect_breaking_changes() {
    local diff="$1"
    local breaking_detected=false
    local breaking_reason=""

    # Check for explicit breaking change keywords in diff
    if echo "$diff" | grep -qiE '^\+.*(BREAKING CHANGE|breaking change|BREAKING:|breaking:)'; then
        breaking_detected=true
        breaking_reason="explicit breaking change keyword in diff"
        echo "true|$breaking_reason"
        return
    fi

    # Check for removal of public APIs/exports
    # Look for lines being removed that contain export, public, or function definitions
    if echo "$diff" | grep -qE '^-.*\b(export (function|class|const|let|var|default|interface|type)|public (class|function|static|final)|def [a-zA-Z_]|function [a-zA-Z_])'; then
        breaking_detected=true
        breaking_reason="removal of public API/function"
        echo "true|$breaking_reason"
        return
    fi

    # Check for major version bumps (0.x.x -> 1.0.0, 1.x.x -> 2.0.0, etc.)
    # Look for version changes in package.json, setup.py, Cargo.toml, etc.
    local old_version=$(echo "$diff" | grep -E '^-.*"version".*:|^-.*version\s*=' | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    local new_version=$(echo "$diff" | grep -E '^\+.*"version".*:|^\+.*version\s*=' | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)

    if [ -n "$old_version" ] && [ -n "$new_version" ]; then
        local old_major=$(echo "$old_version" | cut -d. -f1)
        local new_major=$(echo "$new_version" | cut -d. -f1)

        if [ "$new_major" -gt "$old_major" ]; then
            breaking_detected=true
            breaking_reason="major version bump ($old_version -> $new_version)"
            echo "true|$breaking_reason"
            return
        fi
    fi

    # Check for signature changes (parameter removal/change)
    if echo "$diff" | grep -qE '^-.*\(.*\).*\{' && echo "$diff" | grep -qE '^\+.*\(.*\).*\{'; then
        # Function signatures changed - might be breaking
        # This is a heuristic, not 100% accurate
        local removed_params=$(echo "$diff" | grep -E '^-.*\(.*\)' | grep -oE '\([^)]*\)' | head -1)
        local added_params=$(echo "$diff" | grep -E '^\+.*\(.*\)' | grep -oE '\([^)]*\)' | head -1)

        if [ -n "$removed_params" ] && [ -n "$added_params" ] && [ "$removed_params" != "$added_params" ]; then
            # Count commas to estimate parameter count
            local old_count=$(echo "$removed_params" | tr -cd ',' | wc -c)
            local new_count=$(echo "$added_params" | tr -cd ',' | wc -c)

            if [ "$new_count" -lt "$old_count" ]; then
                breaking_detected=true
                breaking_reason="function signature changed (parameters reduced)"
                echo "true|$breaking_reason"
                return
            fi
        fi
    fi

    echo "false|"
}

# Run breaking change detection
BREAKING_RESULT=$(detect_breaking_changes "$GIT_DIFF")
IS_BREAKING=$(echo "$BREAKING_RESULT" | cut -d'|' -f1)
BREAKING_REASON=$(echo "$BREAKING_RESULT" | cut -d'|' -f2)

# Analyze commit history to learn repository patterns
analyze_commit_history() {
    # Check if we should learn from history
    if [ "$LEARN_FROM_HISTORY" != "true" ]; then
        echo ""
        return
    fi

    # Get last 50 commits (or less if repo is new)
    local commits=$(git log --pretty=format:"%s" -n 50 2>/dev/null)

    if [ -z "$commits" ]; then
        echo ""
        return
    fi

    local total_commits=$(echo "$commits" | wc -l | tr -d ' ')

    # Return early if very few commits
    if [ "$total_commits" -lt 5 ]; then
        echo ""
        return
    fi

    # Detect emoji usage
    local emoji_count=$(echo "$commits" | grep -cE '[\x{1F600}-\x{1F64F}\x{1F300}-\x{1F5FF}\x{1F680}-\x{1F6FF}\x{1F1E0}-\x{1F1FF}\x{2600}-\x{26FF}\x{2700}-\x{27BF}]|:[a-z_]+:' 2>/dev/null || echo "0")
    local uses_emoji=false
    if [ "$emoji_count" -gt 0 ]; then
        uses_emoji=true
    fi

    # Detect scope usage (look for parentheses after type)
    local scope_count=$(echo "$commits" | grep -cE '^[a-z]+\([a-z]+\):' 2>/dev/null || echo "0")
    scope_count=$(echo "$scope_count" | tr -d '\n' | tr -d ' ')
    local uses_scopes=false
    local scope_percentage=0
    if [ "$scope_count" -gt 0 ] 2>/dev/null; then
        uses_scopes=true
        scope_percentage=$((scope_count * 100 / total_commits))
    fi

    # Detect conventional commit types used
    local feat_count=$(echo "$commits" | grep -ciE '^feat[(!:]' 2>/dev/null || echo "0")
    feat_count=$(echo "$feat_count" | tr -d '\n' | tr -d ' ')
    local fix_count=$(echo "$commits" | grep -ciE '^fix[(!:]' 2>/dev/null || echo "0")
    fix_count=$(echo "$fix_count" | tr -d '\n' | tr -d ' ')
    local docs_count=$(echo "$commits" | grep -ciE '^docs[(!:]' 2>/dev/null || echo "0")
    docs_count=$(echo "$docs_count" | tr -d '\n' | tr -d ' ')
    local chore_count=$(echo "$commits" | grep -ciE '^chore[(!:]' 2>/dev/null || echo "0")
    chore_count=$(echo "$chore_count" | tr -d '\n' | tr -d ' ')
    local refactor_count=$(echo "$commits" | grep -ciE '^refactor[(!:]' 2>/dev/null || echo "0")
    refactor_count=$(echo "$refactor_count" | tr -d '\n' | tr -d ' ')
    local test_count=$(echo "$commits" | grep -ciE '^test[(!:]' 2>/dev/null || echo "0")
    test_count=$(echo "$test_count" | tr -d '\n' | tr -d ' ')
    local style_count=$(echo "$commits" | grep -ciE '^style[(!:]' 2>/dev/null || echo "0")
    style_count=$(echo "$style_count" | tr -d '\n' | tr -d ' ')

    # Detect capitalization preference (first word after type)
    local lowercase_count=$(echo "$commits" | grep -cE '^[a-z]+(\([a-z]+\))?!?: [a-z]' 2>/dev/null || echo "0")
    lowercase_count=$(echo "$lowercase_count" | tr -d '\n' | tr -d ' ')
    local uppercase_count=$(echo "$commits" | grep -cE '^[a-z]+(\([a-z]+\))?!?: [A-Z]' 2>/dev/null || echo "0")
    uppercase_count=$(echo "$uppercase_count" | tr -d '\n' | tr -d ' ')
    local prefers_lowercase=true
    if [ "$uppercase_count" -gt "$lowercase_count" ] 2>/dev/null; then
        prefers_lowercase=false
    fi

    # Detect breaking change usage
    local breaking_count=$(echo "$commits" | grep -cE '!:' 2>/dev/null || echo "0")
    breaking_count=$(echo "$breaking_count" | tr -d '\n' | tr -d ' ')
    local uses_breaking_changes=false
    if [ "$breaking_count" -gt 0 ]; then
        uses_breaking_changes=true
    fi

    # Build history insights
    local insights="Repository commit style (based on last $total_commits commits):"

    # Report scope usage
    if [ "$uses_scopes" = "true" ]; then
        insights="$insights\n- Uses scopes in ${scope_percentage}% of commits"
    else
        insights="$insights\n- Rarely uses scopes"
    fi

    # Report type preferences
    local most_common_type="feat"
    local max_count=$feat_count
    [ "$fix_count" -gt "$max_count" ] 2>/dev/null && most_common_type="fix" && max_count=$fix_count
    [ "$docs_count" -gt "$max_count" ] 2>/dev/null && most_common_type="docs" && max_count=$docs_count
    [ "$chore_count" -gt "$max_count" ] 2>/dev/null && most_common_type="chore" && max_count=$chore_count

    insights="$insights\n- Most common type: $most_common_type"

    # Report capitalization
    if [ "$prefers_lowercase" = "true" ]; then
        insights="$insights\n- Prefers lowercase commit messages"
    else
        insights="$insights\n- Uses capitalized commit messages"
    fi

    # Report emoji usage
    if [ "$uses_emoji" = "true" ]; then
        insights="$insights\n- Sometimes uses emojis"
    fi

    # Report breaking change usage
    if [ "$uses_breaking_changes" = "true" ]; then
        insights="$insights\n- Uses breaking change notation (!) when appropriate"
    fi

    insights="$insights\n\nMatch this repository's style in your commit message."

    echo -e "$insights"
}

# Run history analysis if enabled
HISTORY_INSIGHTS=""
if [ "$LEARN_FROM_HISTORY" = "true" ]; then
    HISTORY_INSIGHTS=$(analyze_commit_history)
fi

# Prepare branch context
BRANCH_CONTEXT="Branch context:
- Branch name: $BRANCH_NAME"

if [ -n "$TICKET_NUMBER" ]; then
    BRANCH_CONTEXT="$BRANCH_CONTEXT
- Ticket number: $TICKET_NUMBER (include this in your commit message)"
fi

if [ -n "$SUGGESTED_TYPE" ]; then
    BRANCH_CONTEXT="$BRANCH_CONTEXT
- Suggested type: $SUGGESTED_TYPE (based on $TYPE_SOURCE)"
fi

if [ "$IS_BREAKING" = "true" ]; then
    BRANCH_CONTEXT="$BRANCH_CONTEXT
- BREAKING CHANGE DETECTED: $BREAKING_REASON"
fi

# Prepare closing instruction
CLOSING_INSTRUCTION="Think: What are all the changes? Then: What's the one-line summary that captures all of them?"
if [ -n "$TICKET_NUMBER" ]; then
    CLOSING_INSTRUCTION="$CLOSING_INSTRUCTION Include ticket $TICKET_NUMBER in the summary."
fi
if [ "$IS_BREAKING" = "true" ]; then
    CLOSING_INSTRUCTION="$CLOSING_INSTRUCTION This is a BREAKING CHANGE - add ! after type and include BREAKING CHANGE footer."
fi

# Prepare prompt for Ollama
if [ "$USE_SCOPE" = "true" ]; then
    SCOPE_INSTRUCTION="OUTPUT FORMAT (summary line MUST be first):
<type>(<scope>): <concise summary of all changes below>

The scope should be a short noun describing what part of the codebase changed:
- auth, api, ui, db, cli, docs, config, tests, deps, etc.
- Choose the most relevant scope based on which files/areas changed
- If changes span multiple areas, pick the primary one

BREAKING CHANGES:
- If this is a breaking change, add ! after type: <type>!(<scope>):
- Add a BREAKING CHANGE footer after the bullets explaining the breaking change"
    SCOPE_EXAMPLES="Examples:
- feat(auth): add JWT token validation
- fix(api): resolve timeout in user endpoint
- feat!(api): redesign authentication flow

BREAKING CHANGE: Legacy /auth/login endpoint removed, use /auth/v2/login instead"
else
    SCOPE_INSTRUCTION="OUTPUT FORMAT (summary line MUST be first):
<type>: <concise summary of all changes below>

BREAKING CHANGES:
- If this is a breaking change, add ! after type: <type>!:
- Add a BREAKING CHANGE footer after the bullets explaining the breaking change"
    SCOPE_EXAMPLES="Examples:
- feat: add user authentication
- fix: resolve database connection issue
- feat!: redesign authentication API

BREAKING CHANGE: Legacy /auth/login endpoint removed, use /auth/v2/login instead"
fi

PROMPT="Analyze these git changes and create a commit message.

PROCESS:
1. First, identify all significant changes and list them as bullets
2. Then, synthesize those changes into ONE concise summary line
3. Choose the right type: feat, fix, docs, style, refactor, test, or chore

$SCOPE_INSTRUCTION

- <change 1>
- <change 2>
- <change 3>
- <change 4>

RULES:
- Summary line: max 50 chars, describes the overall purpose
- Use lowercase only (except API, HTTP, JSON, JWT, SQL, ABC-123 tickets)
- Use imperative mood (add/fix not added/fixed)
- The summary should capture the essence of all bullets below it

$SCOPE_EXAMPLES

$BRANCH_CONTEXT

$HISTORY_INSIGHTS

Files changed:
$GIT_STATUS

Stats:
$GIT_STATS

Diff sample:
$GIT_DIFF

$CLOSING_INSTRUCTION"

# Escape JSON strings (replace backslash, double quote, newline, carriage return, tab)
escape_json() {
    echo "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\n/\\n/g; s/\r/\\r/g; s/\t/\\t/g' | awk '{printf "%s\\n", $0}' | sed '$ s/\\n$//'
}

# Enforce lowercase on commit message while preserving acronyms and ticket numbers
enforce_lowercase() {
    local message="$1"
    local temp_message="$message"

    # First, protect ticket numbers by replacing them with placeholders
    # Pattern: ABC-123, JIRA-456, etc.
    local ticket_counter=0
    local tickets_file=$(mktemp)

    # Find all ticket numbers and store them
    echo "$message" | grep -oE '[A-Z][A-Z0-9]+-[0-9]+' > "$tickets_file"

    # Replace tickets with placeholders
    while IFS= read -r ticket; do
        if [ -n "$ticket" ]; then
            temp_message=$(echo "$temp_message" | sed "s/$ticket/__TICKET${ticket_counter}__/g")
            ((ticket_counter++))
        fi
    done < "$tickets_file"

    # Convert entire message to lowercase
    temp_message=$(echo "$temp_message" | tr '[:upper:]' '[:lower:]')

    # Restore ticket numbers
    ticket_counter=0
    while IFS= read -r ticket; do
        if [ -n "$ticket" ]; then
            temp_message=$(echo "$temp_message" | sed "s/__ticket${ticket_counter}__/$ticket/g")
            ((ticket_counter++))
        fi
    done < "$tickets_file"

    rm -f "$tickets_file"

    # Restore common acronyms (case-insensitive search and replace)
    local acronyms="API HTTP HTTPS JSON XML SQL JWT OAuth REST CLI UI UX CSS HTML JS TS URL URI PDF CSV IDE SDK CI CD AWS GCP DNS SSL TLS SSH FTP SMTP TCP UDP IP DOM npm NPM README TODO FIXME"

    for acronym in $acronyms; do
        local lowercase_acronym=$(echo "$acronym" | tr '[:upper:]' '[:lower:]')
        # Use word boundaries to avoid partial matches
        temp_message=$(echo "$temp_message" | sed "s/\b$lowercase_acronym\b/$acronym/g")
    done

    echo "$temp_message"
}

# Parse commit message into components
# Sets global arrays: SUMMARY_LINE and BULLETS
parse_commit_message() {
    local message="$1"
    local line_num=0

    SUMMARY_LINE=""
    BULLETS=()

    while IFS= read -r line; do
        line_num=$((line_num + 1))
        if [ $line_num -eq 1 ]; then
            SUMMARY_LINE="$line"
        elif [ -n "$line" ] && [[ "$line" =~ ^[[:space:]]*-[[:space:]]+ ]]; then
            # This is a bullet point
            BULLETS+=("$line")
        fi
    done <<< "$message"
}

# Rebuild commit message from components
rebuild_commit_message() {
    local result="$SUMMARY_LINE"

    if [ ${#BULLETS[@]} -gt 0 ]; then
        result="$result\n"
        for bullet in "${BULLETS[@]}"; do
            result="$result\n$bullet"
        done
    fi

    echo -e "$result"
}

# Interactive editing menu
interactive_edit_message() {
    local message="$1"

    parse_commit_message "$message"

    while true; do
        clear
        echo -e "${GREEN}=== Interactive Commit Message Editor ===${NC}\n"
        echo -e "${YELLOW}Summary:${NC}"
        echo -e "  $SUMMARY_LINE\n"
        echo -e "${YELLOW}Changes:${NC}"

        if [ ${#BULLETS[@]} -eq 0 ]; then
            echo -e "  (no bullets)\n"
        else
            for i in "${!BULLETS[@]}"; do
                echo -e "  $((i+1)). ${BULLETS[$i]}"
            done
            echo ""
        fi

        echo -e "${GREEN}Options:${NC}"
        echo "  s - Edit summary line"
        echo "  a - Add bullet"
        echo "  r - Remove bullet"
        echo "  o - Reorder bullets"
        echo "  d - Done (return to confirmation)"
        echo "  c - Cancel"
        echo ""

        read -p "Choose option: " -n 1 -r
        echo

        case $REPLY in
            [Ss])
                echo -e "${YELLOW}Current summary:${NC} $SUMMARY_LINE"
                read -p "Enter new summary: " new_summary
                if [ -n "$new_summary" ]; then
                    SUMMARY_LINE="$new_summary"
                fi
                ;;
            [Aa])
                read -p "Enter new bullet (without leading dash): " new_bullet
                if [ -n "$new_bullet" ]; then
                    BULLETS+=("- $new_bullet")
                fi
                ;;
            [Rr])
                if [ ${#BULLETS[@]} -eq 0 ]; then
                    echo -e "${RED}No bullets to remove${NC}"
                    read -p "Press enter to continue..."
                else
                    read -p "Enter bullet number to remove (1-${#BULLETS[@]}): " bullet_num
                    if [[ "$bullet_num" =~ ^[0-9]+$ ]] && [ "$bullet_num" -ge 1 ] && [ "$bullet_num" -le ${#BULLETS[@]} ]; then
                        unset 'BULLETS[$((bullet_num-1))]'
                        BULLETS=("${BULLETS[@]}")  # Re-index array
                    else
                        echo -e "${RED}Invalid bullet number${NC}"
                        read -p "Press enter to continue..."
                    fi
                fi
                ;;
            [Oo])
                if [ ${#BULLETS[@]} -lt 2 ]; then
                    echo -e "${RED}Need at least 2 bullets to reorder${NC}"
                    read -p "Press enter to continue..."
                else
                    read -p "Move bullet number (1-${#BULLETS[@]}): " from_num
                    read -p "To position (1-${#BULLETS[@]}): " to_num

                    if [[ "$from_num" =~ ^[0-9]+$ ]] && [[ "$to_num" =~ ^[0-9]+$ ]] && \
                       [ "$from_num" -ge 1 ] && [ "$from_num" -le ${#BULLETS[@]} ] && \
                       [ "$to_num" -ge 1 ] && [ "$to_num" -le ${#BULLETS[@]} ]; then

                        local from_idx=$((from_num-1))
                        local to_idx=$((to_num-1))
                        local temp="${BULLETS[$from_idx]}"

                        # Remove from old position
                        unset 'BULLETS[$from_idx]'
                        BULLETS=("${BULLETS[@]}")

                        # Adjust target index if needed
                        if [ $from_idx -lt $to_idx ]; then
                            to_idx=$((to_idx-1))
                        fi

                        # Insert at new position
                        BULLETS=("${BULLETS[@]:0:$to_idx}" "$temp" "${BULLETS[@]:$to_idx}")
                    else
                        echo -e "${RED}Invalid bullet numbers${NC}"
                        read -p "Press enter to continue..."
                    fi
                fi
                ;;
            [Dd])
                # Return the edited message
                rebuild_commit_message
                return 0
                ;;
            [Cc])
                # Return original message
                echo "$message"
                return 1
                ;;
            *)
                echo -e "${RED}Invalid option${NC}"
                read -p "Press enter to continue..."
                ;;
        esac
    done
}

# Calculate cost for API usage
calculate_cost() {
    local provider="$1"
    local model="$2"
    local input_tokens="$3"
    local output_tokens="$4"

    # Return early if no token data
    if [ -z "$input_tokens" ] || [ -z "$output_tokens" ]; then
        return
    fi

    local input_cost=0
    local output_cost=0
    local currency="USD"

    # Pricing per 1M tokens (as of early 2025)
    case "$provider" in
        anthropic)
            case "$model" in
                claude-3-5-sonnet-20241022|claude-3-5-sonnet-latest)
                    input_cost=3.00    # $3 per MTok
                    output_cost=15.00  # $15 per MTok
                    ;;
                claude-3-opus-20240229)
                    input_cost=15.00   # $15 per MTok
                    output_cost=75.00  # $75 per MTok
                    ;;
                claude-3-haiku-20240307)
                    input_cost=0.25    # $0.25 per MTok
                    output_cost=1.25   # $1.25 per MTok
                    ;;
                *)
                    # Default to Sonnet pricing
                    input_cost=3.00
                    output_cost=15.00
                    ;;
            esac
            ;;
        openai)
            case "$model" in
                gpt-4o)
                    input_cost=2.50    # $2.50 per MTok
                    output_cost=10.00  # $10 per MTok
                    ;;
                gpt-4o-mini)
                    input_cost=0.15    # $0.15 per MTok
                    output_cost=0.60   # $0.60 per MTok
                    ;;
                gpt-4-turbo|gpt-4-turbo-preview)
                    input_cost=10.00   # $10 per MTok
                    output_cost=30.00  # $30 per MTok
                    ;;
                gpt-4)
                    input_cost=30.00   # $30 per MTok
                    output_cost=60.00  # $60 per MTok
                    ;;
                *)
                    # Default to gpt-4o-mini pricing
                    input_cost=0.15
                    output_cost=0.60
                    ;;
            esac
            ;;
    esac

    # Calculate costs (tokens / 1,000,000 * price per million)
    # Using bc for floating point, or awk if bc not available
    if command -v bc >/dev/null 2>&1; then
        local input_cost_calc=$(echo "scale=6; $input_tokens / 1000000 * $input_cost" | bc)
        local output_cost_calc=$(echo "scale=6; $output_tokens / 1000000 * $output_cost" | bc)
        local total_cost=$(echo "scale=6; $input_cost_calc + $output_cost_calc" | bc)
    else
        # Fallback to awk if bc not available
        local input_cost_calc=$(awk "BEGIN {printf \"%.6f\", $input_tokens / 1000000 * $input_cost}")
        local output_cost_calc=$(awk "BEGIN {printf \"%.6f\", $output_tokens / 1000000 * $output_cost}")
        local total_cost=$(awk "BEGIN {printf \"%.6f\", $input_cost_calc + $output_cost_calc}")
    fi

    # Format for display (remove trailing zeros)
    local total_cost_display=$(echo "$total_cost" | sed 's/0*$//' | sed 's/\.$//')

    # If cost is very small, show more precision
    if [ $(echo "$total_cost < 0.0001" | bc 2>/dev/null || echo 0) -eq 1 ]; then
        total_cost_display=$(printf "%.6f" "$total_cost" | sed 's/0*$//' | sed 's/\.$//')
    else
        total_cost_display=$(printf "%.4f" "$total_cost" | sed 's/0*$//' | sed 's/\.$//')
    fi

    # Display token usage and cost
    local total_tokens=$((input_tokens + output_tokens))
    echo -e "${GREEN}Token usage:${NC} ${total_tokens} tokens (${input_tokens} input + ${output_tokens} output)"
    echo -e "${GREEN}Estimated cost:${NC} \$$total_cost_display $currency"

    # Track cumulative cost
    track_cumulative_cost "$total_cost"
}

# Track cumulative costs
track_cumulative_cost() {
    local cost="$1"
    local cost_file="/tmp/gh-commit-ai-costs-$(date +%Y%m%d)"

    # Append to daily cost file
    echo "$cost" >> "$cost_file"

    # Calculate cumulative total for today
    if command -v bc >/dev/null 2>&1; then
        local cumulative=$(awk '{sum+=$1} END {printf "%.6f", sum}' "$cost_file")
    else
        local cumulative=$(awk '{sum+=$1} END {printf "%.6f", sum}' "$cost_file")
    fi

    # Format for display
    local cumulative_display=$(printf "%.4f" "$cumulative" | sed 's/0*$//' | sed 's/\.$//')

    echo -e "${YELLOW}Today's total:${NC} \$$cumulative_display USD"
}

# Strip ANSI color codes from text
strip_ansi_codes() {
    local text="$1"
    # Remove ANSI escape sequences
    echo "$text" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/\\033\[[0-9;]*m//g'
}

# Call Ollama API
call_ollama() {
    local prompt="$1"
    echo -e "${GREEN}Generating commit message with $OLLAMA_MODEL...${NC}"

    local model_escaped=$(escape_json "$OLLAMA_MODEL")
    local prompt_escaped=$(escape_json "$prompt")
    local json_payload=$(printf '{"model":"%s","prompt":"%s","stream":false}' "$model_escaped" "$prompt_escaped")

    local response=$(curl -s -X POST "$OLLAMA_HOST/api/generate" \
        -H "Content-Type: application/json" \
        -d "$json_payload")

    # Extract commit message from response
    echo "$response" | grep -o '"response":"[^"]*"' | sed 's/"response":"//;s/"$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
}

# Call Anthropic API
call_anthropic() {
    local prompt="$1"

    if [ -z "$ANTHROPIC_API_KEY" ]; then
        echo -e "${RED}Error: ANTHROPIC_API_KEY is not set${NC}"
        exit 1
    fi

    echo -e "${GREEN}Generating commit message with $ANTHROPIC_MODEL...${NC}"

    local prompt_escaped=$(escape_json "$prompt")
    local json_payload=$(printf '{"model":"%s","max_tokens":1024,"messages":[{"role":"user","content":"%s"}]}' "$ANTHROPIC_MODEL" "$prompt_escaped")

    local response=$(curl -s -X POST "https://api.anthropic.com/v1/messages" \
        -H "Content-Type: application/json" \
        -H "x-api-key: $ANTHROPIC_API_KEY" \
        -H "anthropic-version: 2023-06-01" \
        -d "$json_payload")

    # Extract token usage (global variables for cost tracking)
    INPUT_TOKENS=$(echo "$response" | grep -o '"input_tokens":[0-9]*' | head -1 | grep -o '[0-9]*')
    OUTPUT_TOKENS=$(echo "$response" | grep -o '"output_tokens":[0-9]*' | head -1 | grep -o '[0-9]*')

    # Extract commit message from response
    # Anthropic returns: {"content":[{"text":"...","type":"text"}],...}
    echo "$response" | grep -o '"text":"[^"]*"' | head -1 | sed 's/"text":"//;s/"$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
}

# Call OpenAI API
call_openai() {
    local prompt="$1"

    if [ -z "$OPENAI_API_KEY" ]; then
        echo -e "${RED}Error: OPENAI_API_KEY is not set${NC}"
        exit 1
    fi

    echo -e "${GREEN}Generating commit message with $OPENAI_MODEL...${NC}"

    local prompt_escaped=$(escape_json "$prompt")
    local json_payload=$(printf '{"model":"%s","messages":[{"role":"user","content":"%s"}],"temperature":0.7}' "$OPENAI_MODEL" "$prompt_escaped")

    local response=$(curl -s -X POST "https://api.openai.com/v1/chat/completions" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $OPENAI_API_KEY" \
        -d "$json_payload")

    # Extract token usage (global variables for cost tracking)
    INPUT_TOKENS=$(echo "$response" | grep -o '"prompt_tokens":[0-9]*' | head -1 | grep -o '[0-9]*')
    OUTPUT_TOKENS=$(echo "$response" | grep -o '"completion_tokens":[0-9]*' | head -1 | grep -o '[0-9]*')

    # Extract commit message from response
    # OpenAI returns: {"choices":[{"message":{"content":"..."},...}],...}
    echo "$response" | grep -o '"content":"[^"]*"' | head -1 | sed 's/"content":"//;s/"$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
}

# Call the appropriate AI provider
case "$AI_PROVIDER" in
    ollama)
        COMMIT_MSG=$(call_ollama "$PROMPT")
        ;;
    anthropic)
        COMMIT_MSG=$(call_anthropic "$PROMPT")
        ;;
    openai)
        COMMIT_MSG=$(call_openai "$PROMPT")
        ;;
    *)
        echo -e "${RED}Error: Unknown AI provider '$AI_PROVIDER'${NC}"
        echo "Supported providers: ollama, anthropic, openai"
        exit 1
        ;;
esac

if [ -z "$COMMIT_MSG" ] || [ "$COMMIT_MSG" = "null" ]; then
    echo -e "${RED}Error: Failed to generate commit message${NC}"
    echo "Please check your API configuration and try again."
    exit 1
fi

# Enforce lowercase (preserving acronyms and ticket numbers)
COMMIT_MSG=$(enforce_lowercase "$COMMIT_MSG")

# Show the generated commit message
echo -e "\n${GREEN}Generated commit message:${NC}"
echo -e "${YELLOW}$COMMIT_MSG${NC}\n"

# Show cost information for paid APIs
if [ "$AI_PROVIDER" = "anthropic" ]; then
    calculate_cost "anthropic" "$ANTHROPIC_MODEL" "$INPUT_TOKENS" "$OUTPUT_TOKENS"
    echo ""
elif [ "$AI_PROVIDER" = "openai" ]; then
    calculate_cost "openai" "$OPENAI_MODEL" "$INPUT_TOKENS" "$OUTPUT_TOKENS"
    echo ""
fi

# Handle preview mode - just show and exit
if [ "$PREVIEW" = true ]; then
    exit 0
fi

# Handle dry-run mode - ask if user wants to save to file
if [ "$DRY_RUN" = true ]; then
    read -p "Save to file? (y/n): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        COMMIT_FILE=".git/COMMIT_MSG_$(date +%s)"
        # Strip ANSI codes before saving
        CLEAN_MSG=$(strip_ansi_codes "$COMMIT_MSG")
        echo "$CLEAN_MSG" > "$COMMIT_FILE"
        echo -e "${GREEN}✓ Saved to $COMMIT_FILE${NC}"
    else
        echo -e "${YELLOW}Message not saved${NC}"
    fi
    exit 0
fi

# Ask for confirmation (with loop for interactive editing)
while true; do
    read -p "Use this commit message? (y/n/e to edit/i for interactive): " -n 1 -r
    echo

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Strip any ANSI color codes before committing
        CLEAN_MSG=$(strip_ansi_codes "$COMMIT_MSG")

        if [ "$AMEND" = true ]; then
            # Amend the last commit with new message
            git commit --amend -m "$CLEAN_MSG"
            echo -e "${GREEN}✓ Amended commit successfully!${NC}"
        else
            # Stage all changes if nothing is staged
            if git diff --cached --quiet; then
                echo -e "${GREEN}Staging all changes...${NC}"
                git add -A
            fi

            # Commit with the generated message
            git commit -m "$CLEAN_MSG"
            echo -e "${GREEN}✓ Committed successfully!${NC}"
        fi
        break
    elif [[ $REPLY =~ ^[Ee]$ ]]; then
        # Strip any ANSI color codes before editing
        CLEAN_MSG=$(strip_ansi_codes "$COMMIT_MSG")

        # Allow user to edit the message in editor
        if [ "$AMEND" = true ]; then
            git commit --amend -e -m "$CLEAN_MSG"
            echo -e "${GREEN}✓ Amended commit with edited message!${NC}"
        else
            git commit -e -m "$CLEAN_MSG"
            echo -e "${GREEN}✓ Committed with edited message!${NC}"
        fi
        break
    elif [[ $REPLY =~ ^[Ii]$ ]]; then
        # Interactive editing mode
        EDITED_MSG=$(interactive_edit_message "$COMMIT_MSG")
        if [ $? -eq 0 ]; then
            # User completed editing - strip any color codes that might have leaked
            COMMIT_MSG=$(strip_ansi_codes "$EDITED_MSG")
            echo -e "\n${GREEN}Updated commit message:${NC}"
            echo -e "${YELLOW}$COMMIT_MSG${NC}\n"
            # Loop back to confirmation
        else
            # User cancelled interactive editing
            echo -e "${YELLOW}Commit cancelled${NC}"
            exit 0
        fi
    else
        echo -e "${YELLOW}Commit cancelled${NC}"
        exit 0
    fi
done
