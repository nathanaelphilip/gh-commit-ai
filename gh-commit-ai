#!/usr/bin/env bash

set -e

VERSION="1.0.0"

# Colors for output (simplified palette)
RED='\033[38;2;174;32;18m'     # #AE2012 (errors only)
NC='\033[0m' # No Color

# Simple YAML parser (supports only simple key: value pairs)
parse_yaml_config() {
    local config_file="$1"

    if [ ! -f "$config_file" ]; then
        return
    fi

    while IFS=: read -r key value; do
        # Skip comments and empty lines
        [[ "$key" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$key" ]] && continue

        # Trim whitespace
        key=$(echo "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        value=$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

        # Remove quotes from value
        value=$(echo "$value" | sed 's/^["'\'']\|["'\'']$//g')

        # Only set if not already set by environment variable
        case "$key" in
            ai_provider|AI_PROVIDER)
                CONFIG_AI_PROVIDER="${CONFIG_AI_PROVIDER:-$value}"
                ;;
            ollama_model|OLLAMA_MODEL)
                CONFIG_OLLAMA_MODEL="${CONFIG_OLLAMA_MODEL:-$value}"
                ;;
            ollama_host|OLLAMA_HOST)
                CONFIG_OLLAMA_HOST="${CONFIG_OLLAMA_HOST:-$value}"
                ;;
            anthropic_model|ANTHROPIC_MODEL)
                CONFIG_ANTHROPIC_MODEL="${CONFIG_ANTHROPIC_MODEL:-$value}"
                ;;
            openai_model|OPENAI_MODEL)
                CONFIG_OPENAI_MODEL="${CONFIG_OPENAI_MODEL:-$value}"
                ;;
            use_scope|USE_SCOPE)
                CONFIG_USE_SCOPE="${CONFIG_USE_SCOPE:-$value}"
                ;;
            diff_max_lines|DIFF_MAX_LINES)
                CONFIG_DIFF_MAX_LINES="${CONFIG_DIFF_MAX_LINES:-$value}"
                ;;
            learn_from_history|LEARN_FROM_HISTORY)
                CONFIG_LEARN_FROM_HISTORY="${CONFIG_LEARN_FROM_HISTORY:-$value}"
                ;;
            auto_select_model|AUTO_SELECT_MODEL)
                CONFIG_AUTO_SELECT_MODEL="${CONFIG_AUTO_SELECT_MODEL:-$value}"
                ;;
            use_gitmoji|USE_GITMOJI)
                CONFIG_USE_GITMOJI="${CONFIG_USE_GITMOJI:-$value}"
                ;;
        esac
    done < "$config_file"
}

# Load configuration from files (global then local)
# Global config (in user's home directory)
if [ -f "$HOME/.gh-commit-ai.yml" ]; then
    parse_yaml_config "$HOME/.gh-commit-ai.yml"
fi

# Local config (in current repository)
if [ -f ".gh-commit-ai.yml" ]; then
    parse_yaml_config ".gh-commit-ai.yml"
fi

# Configuration (priority: env vars > local config > global config > defaults)
AI_PROVIDER="${AI_PROVIDER:-${CONFIG_AI_PROVIDER:-auto}}"  # Options: auto, ollama, anthropic, openai
OLLAMA_MODEL="${OLLAMA_MODEL:-${CONFIG_OLLAMA_MODEL:-gemma3:12b}}"
OLLAMA_HOST="${OLLAMA_HOST:-${CONFIG_OLLAMA_HOST:-http://localhost:11434}}"
ANTHROPIC_MODEL="${ANTHROPIC_MODEL:-${CONFIG_ANTHROPIC_MODEL:-claude-3-5-sonnet-20241022}}"
ANTHROPIC_API_KEY="${ANTHROPIC_API_KEY:-}"
OPENAI_MODEL="${OPENAI_MODEL:-${CONFIG_OPENAI_MODEL:-gpt-4o-mini}}"
OPENAI_API_KEY="${OPENAI_API_KEY:-}"
DIFF_MAX_LINES="${DIFF_MAX_LINES:-${CONFIG_DIFF_MAX_LINES:-200}}"  # Limit diff lines for faster processing
USE_SCOPE="${USE_SCOPE:-${CONFIG_USE_SCOPE:-false}}"  # Enable/disable conventional commit scopes
USE_GITMOJI="${USE_GITMOJI:-${CONFIG_USE_GITMOJI:-false}}"  # Enable/disable gitmoji prefixes
LEARN_FROM_HISTORY="${LEARN_FROM_HISTORY:-${CONFIG_LEARN_FROM_HISTORY:-true}}"  # Enable/disable learning from commit history
AUTO_SELECT_MODEL="${AUTO_SELECT_MODEL:-${CONFIG_AUTO_SELECT_MODEL:-false}}"  # Auto-select recommended model based on commit size

# Auto-detect available AI providers and models
detect_available_providers() {
    local available=""

    # Check Anthropic (API key set)
    if [ -n "$ANTHROPIC_API_KEY" ]; then
        available="${available}anthropic "
    fi

    # Check OpenAI (API key set)
    if [ -n "$OPENAI_API_KEY" ]; then
        available="${available}openai "
    fi

    # Check Ollama (running and has models)
    if curl -s --connect-timeout 1 "$OLLAMA_HOST/api/tags" >/dev/null 2>&1; then
        local models=$(curl -s "$OLLAMA_HOST/api/tags" 2>/dev/null | grep -o '"name":"[^"]*"' | sed 's/"name":"//;s/"//' | wc -l)
        if [ "$models" -gt 0 ]; then
            available="${available}ollama "
        fi
    fi

    echo "$available" | xargs  # Trim whitespace
}

# Get best available Ollama model
get_best_ollama_model() {
    # Query Ollama for available models
    local models=$(curl -s "$OLLAMA_HOST/api/tags" 2>/dev/null | grep -o '"name":"[^"]*"' | sed 's/"name":"//;s/"//')

    if [ -z "$models" ]; then
        echo ""
        return
    fi

    # Priority list of preferred models (in order of preference)
    # Prefer small-to-medium models that are fast and good for commit messages
    local preferred_models=(
        "qwen2.5-coder:7b"
        "qwen2.5-coder:3b"
        "qwen2.5-coder:1.5b"
        "codellama:7b"
        "codellama:13b"
        "gemma2:9b"
        "gemma2:2b"
        "llama3.2:3b"
        "llama3.2:1b"
        "llama3.1:8b"
        "llama3:8b"
        "mistral:7b"
        "phi3:3.8b"
        "phi3:mini"
    )

    # Check each preferred model in order
    for preferred in "${preferred_models[@]}"; do
        if echo "$models" | grep -q "^${preferred}$"; then
            echo "$preferred"
            return
        fi
    done

    # If no preferred model found, return the first available model
    echo "$models" | head -1
}

# Auto-select provider if set to "auto"
AUTO_DETECTED=false
if [ "$AI_PROVIDER" = "auto" ]; then
    # Detect what's available
    available_providers=$(detect_available_providers)

    if [ -z "$available_providers" ]; then
        echo -e "${RED}Error: No AI providers available${NC}"
        echo ""
        echo "Available options:"
        echo "  1. Install Ollama (free, local): https://ollama.ai"
        echo "     Then run: ollama pull qwen2.5-coder:7b"
        echo ""
        echo "  2. Set up Anthropic API:"
        echo "     export ANTHROPIC_API_KEY=\"sk-ant-...\""
        echo ""
        echo "  3. Set up OpenAI API:"
        echo "     export OPENAI_API_KEY=\"sk-proj-...\""
        exit 1
    fi

    # Pick the best available provider (prefer local/free first, then API providers)
    if echo "$available_providers" | grep -q "ollama"; then
        AI_PROVIDER="ollama"
        # Auto-select best Ollama model
        detected_model=$(get_best_ollama_model)
        if [ -n "$detected_model" ]; then
            OLLAMA_MODEL="$detected_model"
            AUTO_DETECTED=true
        fi
    elif echo "$available_providers" | grep -q "anthropic"; then
        AI_PROVIDER="anthropic"
        AUTO_DETECTED=true
    elif echo "$available_providers" | grep -q "openai"; then
        AI_PROVIDER="openai"
        AUTO_DETECTED=true
    fi
fi

# Generate changelog from commit history
generate_changelog() {
    local since_ref="$1"
    local format="$2"

    # Build git log command
    local log_cmd="git log --pretty=format:'%H|%s|%b' --no-merges"
    if [ -n "$since_ref" ]; then
        # Check if the reference exists
        if ! git rev-parse "$since_ref" >/dev/null 2>&1; then
            echo -e "${RED}Error: Reference '$since_ref' not found"
            exit 1
        fi
        log_cmd="$log_cmd ${since_ref}..HEAD"
    fi

    # Get commits
    local commits=$(eval "$log_cmd")

    if [ -z "$commits" ]; then
        echo "No commits found"
        exit 0
    fi

    # Initialize arrays for different types
    local breaking_changes=()
    local features=()
    local fixes=()
    local docs=()
    local style=()
    local refactor=()
    local performance=()
    local tests=()
    local chores=()
    local other=()

    # Parse commits
    while IFS='|' read -r hash subject body; do
        # Parse conventional commit format
        local type=""
        local scope=""
        local description=""
        local is_breaking=false

        # Check for breaking change indicator
        if [[ "$subject" =~ ^([a-z]+)(\([a-z0-9_-]+\))?!:\ (.+)$ ]]; then
            type="${BASH_REMATCH[1]}"
            scope="${BASH_REMATCH[2]}"
            description="${BASH_REMATCH[3]}"
            is_breaking=true
        elif [[ "$subject" =~ ^([a-z]+)(\([a-z0-9_-]+\))?:\ (.+)$ ]]; then
            type="${BASH_REMATCH[1]}"
            scope="${BASH_REMATCH[2]}"
            description="${BASH_REMATCH[3]}"
        else
            # Not a conventional commit, skip or put in other
            type="other"
            description="$subject"
        fi

        # Remove parentheses from scope
        scope="${scope#(}"
        scope="${scope%)}"

        # Check body for BREAKING CHANGE
        if echo "$body" | grep -qiE '^BREAKING CHANGE:'; then
            is_breaking=true
        fi

        # Format entry
        local entry="- $description"
        if [ -n "$scope" ]; then
            entry="- **$scope**: $description"
        fi
        entry="$entry ([${hash:0:7}](../../commit/$hash))"

        # Categorize by type
        if [ "$is_breaking" = true ]; then
            breaking_changes+=("$entry")
        fi

        case "$type" in
            feat|feature)
                features+=("$entry")
                ;;
            fix)
                fixes+=("$entry")
                ;;
            docs)
                docs+=("$entry")
                ;;
            style)
                style+=("$entry")
                ;;
            refactor)
                refactor+=("$entry")
                ;;
            perf|performance)
                performance+=("$entry")
                ;;
            test|tests)
                tests+=("$entry")
                ;;
            chore|build|ci)
                chores+=("$entry")
                ;;
            *)
                other+=("$entry")
                ;;
        esac
    done <<< "$commits"

    # Generate changelog based on format
    echo ""
    echo "# Changelog"
    echo ""

    # Determine version header
    local version_header="Unreleased"
    if [ -n "$since_ref" ]; then
        # Try to get the next version from the since ref
        local current_version="$since_ref"
        version_header="[${current_version#v}...HEAD]"
    fi

    echo "## $version_header"
    echo ""
    echo "### Date: $(date +%Y-%m-%d)"
    echo ""

    # Breaking changes first (most important)
    if [ ${#breaking_changes[@]} -gt 0 ]; then
        echo "### ‚ö†Ô∏è BREAKING CHANGES"
        echo ""
        for entry in "${breaking_changes[@]}"; do
            echo "$entry"
        done
        echo ""
    fi

    # Features
    if [ ${#features[@]} -gt 0 ]; then
        echo "### ‚ú® Features"
        echo ""
        for entry in "${features[@]}"; do
            echo "$entry"
        done
        echo ""
    fi

    # Bug fixes
    if [ ${#fixes[@]} -gt 0 ]; then
        echo "### üêõ Bug Fixes"
        echo ""
        for entry in "${fixes[@]}"; do
            echo "$entry"
        done
        echo ""
    fi

    # Documentation
    if [ ${#docs[@]} -gt 0 ]; then
        echo "### üìù Documentation"
        echo ""
        for entry in "${docs[@]}"; do
            echo "$entry"
        done
        echo ""
    fi

    # Performance improvements
    if [ ${#performance[@]} -gt 0 ]; then
        echo "### ‚ö° Performance"
        echo ""
        for entry in "${performance[@]}"; do
            echo "$entry"
        done
        echo ""
    fi

    # Refactoring
    if [ ${#refactor[@]} -gt 0 ]; then
        echo "### ‚ôªÔ∏è Refactoring"
        echo ""
        for entry in "${refactor[@]}"; do
            echo "$entry"
        done
        echo ""
    fi

    # Tests
    if [ ${#tests[@]} -gt 0 ]; then
        echo "### ‚úÖ Tests"
        echo ""
        for entry in "${tests[@]}"; do
            echo "$entry"
        done
        echo ""
    fi

    # Style changes
    if [ ${#style[@]} -gt 0 ]; then
        echo "### üíÑ Style"
        echo ""
        for entry in "${style[@]}"; do
            echo "$entry"
        done
        echo ""
    fi

    # Chores
    if [ ${#chores[@]} -gt 0 ]; then
        echo "### üîß Chores"
        echo ""
        for entry in "${chores[@]}"; do
            echo "$entry"
        done
        echo ""
    fi

    # Other
    if [ ${#other[@]} -gt 0 ]; then
        echo "### Other Changes"
        echo ""
        for entry in "${other[@]}"; do
            echo "$entry"
        done
        echo ""
    fi
}

# Parse command-line arguments
DRY_RUN=false
PREVIEW=false
AMEND=false
MULTIPLE_OPTIONS=false
CHANGELOG_MODE=false
CHANGELOG_SINCE=""
CHANGELOG_FORMAT="keepachangelog"
VERBOSE=false
FORCED_TYPE=""
CUSTOM_MAX_LINES=""
NO_LOWERCASE=false

### Message history directory
MESSAGE_HISTORY_DIR="/tmp/gh-commit-ai-history"
mkdir -p "$MESSAGE_HISTORY_DIR"

# Save message to history (keeps last 5)
save_message_history() {
    local message="$1"
    local timestamp=$(date +%s)
    local history_file="$MESSAGE_HISTORY_DIR/msg_${timestamp}.txt"

    # Save the message
    echo "$message" > "$history_file"

    # Keep only the last 5 messages
    ls -t "$MESSAGE_HISTORY_DIR"/msg_*.txt 2>/dev/null | tail -n +6 | xargs rm -f 2>/dev/null || true
}

# Check for subcommands
if [ "$1" = "changelog" ]; then
    CHANGELOG_MODE=true
    shift

    # Parse changelog-specific flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --since)
                CHANGELOG_SINCE="$2"
                shift 2
                ;;
            --format)
                CHANGELOG_FORMAT="$2"
                shift 2
                ;;
            --help|-h)
                echo "gh-commit-ai changelog - Generate changelog from commit history"
                echo ""
                echo "Usage: gh commit-ai changelog [options]"
                echo ""
                echo "Options:"
                echo "  --since <ref>   Generate changelog since tag/commit (e.g., v1.0.0)"
                echo "  --format <fmt>  Changelog format (default: keepachangelog)"
                echo "  --help, -h      Show this help message"
                echo ""
                echo "Examples:"
                echo "  gh commit-ai changelog"
                echo "  gh commit-ai changelog --since v1.0.0"
                echo "  gh commit-ai changelog --since HEAD~10"
                exit 0
                ;;
            *)
                echo -e "${RED}Error: Unknown changelog option $1"
                echo "Use 'gh commit-ai changelog --help' for usage information"
                exit 1
                ;;
        esac
    done
elif [ "$1" = "install-hook" ]; then
    # Install prepare-commit-msg hook
    HOOK_DIR=".git/hooks"
    HOOK_FILE="$HOOK_DIR/prepare-commit-msg"

    # Check if we're in a git repository
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo -e "${RED}Error: Not a git repository"
        exit 1
    fi

    # Create hooks directory if it doesn't exist
    mkdir -p "$HOOK_DIR"

    # Check if hook already exists
    if [ -f "$HOOK_FILE" ]; then
        # Check if it's our hook
        if grep -q "gh-commit-ai hook" "$HOOK_FILE" 2>/dev/null; then
            echo "Hook already installed"
            exit 0
        else
            echo -e "${RED}Error: A prepare-commit-msg hook already exists"
            echo "Please manually merge or remove: $HOOK_FILE"
            exit 1
        fi
    fi

    # Create the hook
    cat > "$HOOK_FILE" << 'EOF'
#!/bin/bash
# gh-commit-ai hook
# This hook is OPT-IN: only runs when GH_COMMIT_AI=1

COMMIT_MSG_FILE="$1"
COMMIT_SOURCE="$2"

# Only run if explicitly enabled via environment variable
if [ "$GH_COMMIT_AI" != "1" ]; then
    exit 0
fi

# Don't run for merge commits, squash, or amend
if [ "$COMMIT_SOURCE" = "merge" ] || [ "$COMMIT_SOURCE" = "squash" ] || [ "$COMMIT_SOURCE" = "commit" ]; then
    exit 0
fi

# Generate commit message using gh-commit-ai
echo "Generating commit message with AI" >&2

# Run gh-commit-ai in preview mode to get the message
GENERATED_MSG=$(gh commit-ai --preview 2>&1 | grep -A 1000 "Generated commit message:" | tail -n +2)

if [ -n "$GENERATED_MSG" ]; then
    # Write the generated message to the commit message file
    echo "$GENERATED_MSG" > "$COMMIT_MSG_FILE"
    echo "‚úì AI-generated message added. Review and edit if needed." >&2
else
    echo "‚úó Failed to generate message, opening editor with empty message" >&2
fi
EOF

    chmod +x "$HOOK_FILE"

    echo "‚úì Pre-commit hook installed successfully!"
    echo ""
    echo "Usage (OPT-IN):"
    echo "  1. Regular commits work normally:"
    echo "     git commit"
    echo ""
    echo "  2. Use AI generation when you want it:"
    echo "     GH_COMMIT_AI=1 git commit"
    echo ""
    echo "  3. Or set up a convenient alias:"
    echo "     git config alias.ai-commit '!GH_COMMIT_AI=1 git commit'"
    echo "     git ai-commit    # Use AI generation"
    echo ""
    echo "To uninstall: gh commit-ai uninstall-hook"

    exit 0

elif [ "$1" = "uninstall-hook" ]; then
    # Uninstall prepare-commit-msg hook
    HOOK_FILE=".git/hooks/prepare-commit-msg"

    # Check if we're in a git repository
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo -e "${RED}Error: Not a git repository"
        exit 1
    fi

    if [ ! -f "$HOOK_FILE" ]; then
        echo "No hook to uninstall"
        exit 0
    fi

    # Check if it's our hook
    if ! grep -q "gh-commit-ai hook" "$HOOK_FILE" 2>/dev/null; then
        echo -e "${RED}Error: Hook file exists but is not from gh-commit-ai"
        echo "Please manually review: $HOOK_FILE"
        exit 1
    fi

    rm "$HOOK_FILE"
    echo "‚úì Pre-commit hook uninstalled successfully"

    # Also remove the git alias if it exists
    if git config --get alias.ai-commit > /dev/null 2>&1; then
        echo ""
        echo "Note: Git alias 'ai-commit' still exists. To remove it:"
        echo "  git config --unset alias.ai-commit"
    fi

    exit 0
fi

while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --preview)
            PREVIEW=true
            shift
            ;;
        --amend)
            AMEND=true
            shift
            ;;
        --options)
            MULTIPLE_OPTIONS=true
            shift
            ;;
        --version)
            echo "gh-commit-ai version $VERSION"
            exit 0
            ;;
        --verbose|-v)
            VERBOSE=true
            shift
            ;;
        --type)
            FORCED_TYPE="$2"
            shift 2
            ;;
        --max-lines)
            CUSTOM_MAX_LINES="$2"
            shift 2
            ;;
        --no-lowercase)
            NO_LOWERCASE=true
            shift
            ;;
        --help|-h)
            echo "gh-commit-ai - AI-powered git commit message generator"
            echo ""
            echo "Usage: gh commit-ai [options]"
            echo "       gh commit-ai <command> [options]"
            echo ""
            echo "Commands:"
            echo "  (default)       Generate commit message for current changes"
            echo "  changelog       Generate changelog from commit history"
            echo "  install-hook    Install git hook for opt-in AI commits"
            echo "  uninstall-hook  Remove git hook"
            echo ""
            echo "Options:"
            echo "  --dry-run           Generate commit message without committing"
            echo "  --preview           Generate and display message, then exit"
            echo "  --amend             Regenerate message for last commit"
            echo "  --options           Generate multiple variations to choose from"
            echo "  --type <type>       Force a specific commit type (feat, fix, docs, etc.)"
            echo "  --max-lines <n>     Override DIFF_MAX_LINES for this run"
            echo "  --no-lowercase      Disable automatic lowercase enforcement"
            echo "  --verbose, -v       Show detailed API request/response info"
            echo "  --version           Show version number"
            echo "  --help, -h          Show this help message"
            echo ""
            echo "Interactive Options (when reviewing commit message):"
            echo "  y - Accept and commit"
            echo "  n - Cancel"
            echo "  e - Edit in your default editor"
            echo ""
            echo "Environment Variables:"
            echo "  AI_PROVIDER         AI provider (auto, ollama, anthropic, openai)"
            echo "                      Default: auto (detects what's available)"
            echo "  USE_SCOPE           Enable/disable scopes (true/false)"
            echo "  USE_GITMOJI         Enable/disable gitmoji prefixes (true/false)"
            echo "  DIFF_MAX_LINES      Maximum diff lines to send to AI"
            echo "  AUTO_SELECT_MODEL   Auto-select model based on commit size (true/false)"
            echo "  GH_COMMIT_AI        Set to 1 to enable hook (opt-in)"
            echo ""
            echo "Configuration Files:"
            echo "  .gh-commit-ai.yml       Local config (repo root)"
            echo "  ~/.gh-commit-ai.yml     Global config"
            echo ""
            echo "Examples:"
            echo "  gh commit-ai"
            echo "  gh commit-ai --dry-run"
            echo "  gh commit-ai --preview"
            echo "  gh commit-ai --amend"
            echo "  gh commit-ai changelog"
            echo "  gh commit-ai changelog --since v1.0.0"
            echo "  gh commit-ai install-hook"
            echo "  GH_COMMIT_AI=1 git commit    # With hook installed"
            echo "  USE_SCOPE=false gh commit-ai"
            echo "  USE_GITMOJI=true gh commit-ai"
            exit 0
            ;;
        *)
            echo -e "${RED}Error: Unknown option $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Apply command-line overrides
if [ -n "$CUSTOM_MAX_LINES" ]; then
    DIFF_MAX_LINES="$CUSTOM_MAX_LINES"
fi

# Show spinner while waiting
show_spinner() {
    local pid=$1
    local message="$2"
    local delay=0.15
    local arrows=("‚Üê" "‚Üñ" "‚Üë" "‚Üó" "‚Üí" "‚Üò" "‚Üì" "‚Üô")
    local i=0

    while kill -0 "$pid" 2>/dev/null; do
        printf "\r${arrows[$i]} ${message}" >&2
        i=$(( (i + 1) % 8 ))
        sleep $delay
    done
    printf "\r%-50s\r" " " >&2  # Clear the line
}

# Intelligently sample diff for large changes
# Prioritizes: function signatures > added lines > context > deleted lines
smart_sample_diff() {
    local full_diff="$1"
    local max_lines="$2"

    # Count total lines
    local total_lines=$(echo "$full_diff" | wc -l | tr -d ' ')

    # If under limit, return full diff
    if [ "$total_lines" -le "$max_lines" ]; then
        echo "$full_diff"
        return
    fi

    # Otherwise, intelligently sample
    local temp_file="/tmp/gh-commit-ai-smart-sample-$$"
    echo "$full_diff" > "$temp_file"

    # Extract high-priority lines
    local priority_file="/tmp/gh-commit-ai-priority-$$"
    > "$priority_file"

    # Priority 1: File headers and chunk headers (MUST keep)
    grep -E '^(diff --git|index |---|\+\+\+|@@)' "$temp_file" >> "$priority_file" 2>/dev/null || true

    # Priority 2: Function/class definitions (HIGH priority)
    grep -E '^\+.*(function |def |class |const |export |public |private |func )' "$temp_file" >> "$priority_file" 2>/dev/null || true

    # Priority 3: Added lines (MEDIUM-HIGH priority)
    # Sample added lines evenly throughout the diff
    local added_lines=$(grep -n '^\+[^+]' "$temp_file" | wc -l | tr -d ' ')
    if [ "$added_lines" -gt 0 ]; then
        # Calculate sample rate to get ~40% of max_lines from added lines
        local target_added=$((max_lines * 40 / 100))
        local sample_rate=$((added_lines / target_added + 1))

        grep -n '^\+[^+]' "$temp_file" | awk -v rate="$sample_rate" 'NR % rate == 1' | cut -d: -f1 | while read line_num; do
            sed -n "${line_num}p" "$temp_file" >> "$priority_file"
        done
    fi

    # Priority 4: Context lines around changes (MEDIUM priority)
    # Get a few context lines for readability
    grep -E '^ [a-zA-Z]' "$temp_file" | head -n $((max_lines * 20 / 100)) >> "$priority_file" 2>/dev/null || true

    # Priority 5: Deleted lines (LOW priority) - only sample if we have room
    local current_count=$(cat "$priority_file" | wc -l | tr -d ' ')
    if [ "$current_count" -lt "$max_lines" ]; then
        local remaining=$((max_lines - current_count))
        grep -E '^\-[^-]' "$temp_file" | head -n $((remaining / 2)) >> "$priority_file" 2>/dev/null || true
    fi

    # Sort by line number to maintain diff structure, remove duplicates, and limit
    cat "$priority_file" | sort -u | head -n "$max_lines"

    # Cleanup
    rm -f "$temp_file" "$priority_file"
}

# Analyze commit size (count lines changed)
analyze_commit_size() {
    local diff="$1"

    # Count added and deleted lines (ignore context lines)
    local added=$(echo "$diff" | grep -c '^\+[^+]' 2>/dev/null || echo "0")
    local deleted=$(echo "$diff" | grep -c '^\-[^-]' 2>/dev/null || echo "0")
    local total=$((added + deleted))

    echo "$total"
}

# Recommend model based on commit size
recommend_model() {
    local size="$1"
    local provider="$2"
    local current_model="$3"

    # Define size categories
    local category=""
    if [ "$size" -lt 100 ]; then
        category="small"
    elif [ "$size" -lt 500 ]; then
        category="medium"
    else
        category="large"
    fi

    # Recommend models based on provider and size
    case "$provider" in
        ollama)
            case "$category" in
                small)
                    echo "gemma2:2b"
                    ;;
                medium)
                    echo "gemma3:12b"
                    ;;
                large)
                    echo "llama3.3:70b"
                    ;;
            esac
            ;;
        anthropic)
            case "$category" in
                small)
                    echo "claude-3-5-haiku-20241022"
                    ;;
                medium)
                    echo "claude-3-5-sonnet-20241022"
                    ;;
                large)
                    echo "claude-3-5-sonnet-20241022"
                    ;;
            esac
            ;;
        openai)
            case "$category" in
                small)
                    echo "gpt-4o-mini"
                    ;;
                medium)
                    echo "gpt-4o-mini"
                    ;;
                large)
                    echo "gpt-4o"
                    ;;
            esac
            ;;
    esac
}

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo -e "${RED}Error: Not a git repository"
    exit 1
fi

# Handle changelog mode
if [ "$CHANGELOG_MODE" = true ]; then
    echo "Generating changelog"
    generate_changelog "$CHANGELOG_SINCE" "$CHANGELOG_FORMAT"
    exit 0
fi

# Handle amend mode differently
if [ "$AMEND" = true ]; then
    # Check if there's at least one commit
    if ! git rev-parse HEAD >/dev/null 2>&1; then
        echo -e "${RED}Error: No commits to amend"
        exit 1
    fi

    # Get the changes from the last commit with loading animation
    (
        GIT_STATUS=$(git show --name-status --pretty=format:"" HEAD | grep -E '^[AMDRC]' | awk '{print $1 " " $2}')
        GIT_STATS=$(git show --stat HEAD | tail -n +2)

        # Get full diff and intelligently sample it
        FULL_DIFF=$(git show HEAD)
        GIT_DIFF=$(smart_sample_diff "$FULL_DIFF" "$DIFF_MAX_LINES")

        # Calculate commit size (lines added + deleted)
        COMMIT_SIZE=$(git show --numstat HEAD | awk '{added+=$1; deleted+=$2} END {print added+deleted}')

        # Export to temp file for parent process
        echo "$GIT_STATUS" > /tmp/gh-commit-ai-status-$$
        echo "$GIT_STATS" > /tmp/gh-commit-ai-stats-$$
        echo "$GIT_DIFF" > /tmp/gh-commit-ai-diff-$$
        echo "$COMMIT_SIZE" > /tmp/gh-commit-ai-size-$$
    ) &
    ANALYZE_PID=$!

    show_spinner "$ANALYZE_PID" "Analyzing last commit"
    wait "$ANALYZE_PID"

    # Read results from temp files
    GIT_STATUS=$(cat /tmp/gh-commit-ai-status-$$ 2>/dev/null || echo "")
    GIT_STATS=$(cat /tmp/gh-commit-ai-stats-$$ 2>/dev/null || echo "")
    GIT_DIFF=$(cat /tmp/gh-commit-ai-diff-$$ 2>/dev/null || echo "")
    COMMIT_SIZE=$(cat /tmp/gh-commit-ai-size-$$ 2>/dev/null || echo "0")
    rm -f /tmp/gh-commit-ai-status-$$ /tmp/gh-commit-ai-stats-$$ /tmp/gh-commit-ai-diff-$$ /tmp/gh-commit-ai-size-$$

    echo "‚úì Commit analyzed"
else
    # Check if there are changes to commit
    if git diff --cached --quiet && git diff --quiet; then
        echo "No changes to commit"
        exit 0
    fi

    # Get git status and diff with loading animation
    (
        GIT_STATUS=$(git status --short)

        # Get diff stats for overview
        GIT_STATS=$(git diff --cached --stat 2>/dev/null || echo "")
        if [ -z "$GIT_STATS" ]; then
            GIT_STATS=$(git diff --stat 2>/dev/null || echo "")
        fi

        # Get full diff and intelligently sample it
        FULL_DIFF=$(git diff --cached 2>/dev/null || echo "")
        if [ -z "$FULL_DIFF" ]; then
            FULL_DIFF=$(git diff 2>/dev/null || echo "")
        fi
        GIT_DIFF=$(smart_sample_diff "$FULL_DIFF" "$DIFF_MAX_LINES")

        # Calculate commit size (lines added + deleted)
        COMMIT_SIZE=$(git diff --cached --numstat 2>/dev/null | awk '{added+=$1; deleted+=$2} END {print added+deleted}')
        if [ -z "$COMMIT_SIZE" ] || [ "$COMMIT_SIZE" = "0" ]; then
            COMMIT_SIZE=$(git diff --numstat 2>/dev/null | awk '{added+=$1; deleted+=$2} END {print added+deleted}')
        fi

        # Export to temp file for parent process
        echo "$GIT_STATUS" > /tmp/gh-commit-ai-status-$$
        echo "$GIT_STATS" > /tmp/gh-commit-ai-stats-$$
        echo "$GIT_DIFF" > /tmp/gh-commit-ai-diff-$$
        echo "$COMMIT_SIZE" > /tmp/gh-commit-ai-size-$$
    ) &
    ANALYZE_PID=$!

    show_spinner "$ANALYZE_PID" "Analyzing changes"
    wait "$ANALYZE_PID"

    # Read results from temp files
    GIT_STATUS=$(cat /tmp/gh-commit-ai-status-$$ 2>/dev/null || echo "")
    GIT_STATS=$(cat /tmp/gh-commit-ai-stats-$$ 2>/dev/null || echo "")
    GIT_DIFF=$(cat /tmp/gh-commit-ai-diff-$$ 2>/dev/null || echo "")
    COMMIT_SIZE=$(cat /tmp/gh-commit-ai-size-$$ 2>/dev/null || echo "0")
    rm -f /tmp/gh-commit-ai-status-$$ /tmp/gh-commit-ai-stats-$$ /tmp/gh-commit-ai-diff-$$ /tmp/gh-commit-ai-size-$$

    echo "‚úì Changes analyzed"

    # Show auto-detection info if applicable
    if [ "$AUTO_DETECTED" = "true" ]; then
        case "$AI_PROVIDER" in
            ollama)
                echo "Using Ollama with model: $OLLAMA_MODEL (auto-detected)"
                ;;
            anthropic)
                echo "Using Anthropic Claude (auto-detected)"
                ;;
            openai)
                echo "Using OpenAI (auto-detected)"
                ;;
        esac
    fi
fi

# Model recommendation based on commit size
if [ -n "$COMMIT_SIZE" ] && [ "$COMMIT_SIZE" != "0" ]; then
    RECOMMENDED_MODEL=$(recommend_model "$COMMIT_SIZE" "$AI_PROVIDER" "")

    if [ "$AUTO_SELECT_MODEL" = "true" ] && [ -n "$RECOMMENDED_MODEL" ]; then
        # Auto-select the recommended model
        case "$AI_PROVIDER" in
            ollama) OLLAMA_MODEL="$RECOMMENDED_MODEL" ;;
            anthropic) ANTHROPIC_MODEL="$RECOMMENDED_MODEL" ;;
            openai) OPENAI_MODEL="$RECOMMENDED_MODEL" ;;
        esac
        echo "Model auto-selected: $RECOMMENDED_MODEL (${COMMIT_SIZE} lines changed)"
    elif [ -n "$RECOMMENDED_MODEL" ]; then
        # Show recommendation but don't auto-select
        CURRENT_MODEL=""
        case "$AI_PROVIDER" in
            ollama) CURRENT_MODEL="$OLLAMA_MODEL" ;;
            anthropic) CURRENT_MODEL="$ANTHROPIC_MODEL" ;;
            openai) CURRENT_MODEL="$OPENAI_MODEL" ;;
        esac

        if [ "$RECOMMENDED_MODEL" != "$CURRENT_MODEL" ]; then
            echo "Tip: For ${COMMIT_SIZE} lines changed, consider using $RECOMMENDED_MODEL"
        fi
    fi
fi

# Get current branch name
BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")

# Extract ticket number from branch name (e.g., feature/ABC-123-description ‚Üí ABC-123)
TICKET_NUMBER=""
if [ -n "$BRANCH_NAME" ]; then
    TICKET_NUMBER=$(echo "$BRANCH_NAME" | grep -oE '[A-Z][A-Z0-9]+-[0-9]+' | head -1)
fi

# Detect suggested type from branch name
SUGGESTED_TYPE=""
if [ -n "$BRANCH_NAME" ]; then
    case "$BRANCH_NAME" in
        feat/*|feature/*) SUGGESTED_TYPE="feat" ;;
        fix/*|bugfix/*|hotfix/*) SUGGESTED_TYPE="fix" ;;
        docs/*|doc/*) SUGGESTED_TYPE="docs" ;;
        style/*) SUGGESTED_TYPE="style" ;;
        refactor/*) SUGGESTED_TYPE="refactor" ;;
        test/*|tests/*) SUGGESTED_TYPE="test" ;;
        chore/*) SUGGESTED_TYPE="chore" ;;
    esac
fi

# Smart type detection based on changed files and content
detect_smart_type() {
    local files="$1"
    local diff="$2"

    # Get list of changed files (extract filenames from git status)
    local changed_files=$(echo "$files" | awk '{print $NF}')

    # Count different file types
    local doc_count=0
    local test_count=0
    local config_count=0
    local code_count=0
    local total_count=0

    while IFS= read -r file; do
        [ -z "$file" ] && continue
        total_count=$((total_count + 1))

        # Check for documentation files
        if [[ "$file" =~ \.(md|txt|rst|adoc)$ ]] || [[ "$file" =~ ^docs?/ ]] || [[ "$file" =~ ^documentation/ ]] || [[ "$file" =~ README|CHANGELOG|LICENSE ]]; then
            doc_count=$((doc_count + 1))
        # Check for test files
        elif [[ "$file" =~ ^tests?/ ]] || [[ "$file" =~ \.(test|spec)\. ]] || [[ "$file" =~ [_-](test|spec)\. ]] || [[ "$file" =~ __tests?__/ ]]; then
            test_count=$((test_count + 1))
        # Check for config files
        elif [[ "$file" =~ \.(json|ya?ml|toml|ini|conf|config)$ ]] || [[ "$file" =~ ^\..*rc$ ]] || [[ "$file" =~ package\.json|setup\.py|Cargo\.toml|go\.mod ]]; then
            config_count=$((config_count + 1))
        else
            code_count=$((code_count + 1))
        fi
    done <<< "$changed_files"

    # Return early if no files detected
    [ $total_count -eq 0 ] && return

    # If only docs changed, suggest docs
    if [ $doc_count -gt 0 ] && [ $test_count -eq 0 ] && [ $code_count -eq 0 ]; then
        echo "docs"
        return
    fi

    # If only tests changed, suggest test
    if [ $test_count -gt 0 ] && [ $doc_count -eq 0 ] && [ $code_count -eq 0 ]; then
        echo "test"
        return
    fi

    # Check for version bumps in config files
    if [ $config_count -gt 0 ]; then
        if echo "$diff" | grep -qE '^\+.*"version".*:' || \
           echo "$diff" | grep -qE '^\+.*version\s*='; then
            echo "chore"
            return
        fi
    fi

    # Check for bug-related keywords in diff
    if echo "$diff" | grep -qiE '^\+.*(fix|bug|issue|error|crash|problem|broken|incorrect|wrong)'; then
        echo "fix"
        return
    fi

    # No strong signal detected
    echo ""
}

# Run smart type detection
SMART_TYPE=$(detect_smart_type "$GIT_STATUS" "$GIT_DIFF")

# Track where the suggestion came from for better prompting
TYPE_SOURCE=""
if [ -n "$SUGGESTED_TYPE" ]; then
    TYPE_SOURCE="branch name"
fi

# Smart type detection can override if branch gives no suggestion
if [ -z "$SUGGESTED_TYPE" ] && [ -n "$SMART_TYPE" ]; then
    SUGGESTED_TYPE="$SMART_TYPE"
    TYPE_SOURCE="file analysis"
elif [ -n "$SMART_TYPE" ] && [ "$SMART_TYPE" != "$SUGGESTED_TYPE" ]; then
    # Both exist but differ - mention both in context
    TYPE_SOURCE="branch name (smart detection also suggests: $SMART_TYPE)"
fi

# Override with forced type if provided
if [ -n "$FORCED_TYPE" ]; then
    SUGGESTED_TYPE="$FORCED_TYPE"
    TYPE_SOURCE="user-specified via --type flag"
fi

# Detect breaking changes
detect_breaking_changes() {
    local diff="$1"
    local breaking_detected=false
    local breaking_reason=""

    # Check for explicit breaking change keywords in diff
    if echo "$diff" | grep -qiE '^\+.*(BREAKING CHANGE|breaking change|BREAKING:|breaking:)'; then
        breaking_detected=true
        breaking_reason="explicit breaking change keyword in diff"
        echo "true|$breaking_reason"
        return
    fi

    # Check for removal of public APIs/exports
    # Look for lines being removed that contain export, public, or function definitions
    if echo "$diff" | grep -qE '^-.*\b(export (function|class|const|let|var|default|interface|type)|public (class|function|static|final)|def [a-zA-Z_]|function [a-zA-Z_])'; then
        breaking_detected=true
        breaking_reason="removal of public API/function"
        echo "true|$breaking_reason"
        return
    fi

    # Check for major version bumps (0.x.x -> 1.0.0, 1.x.x -> 2.0.0, etc.)
    # Look for version changes in package.json, setup.py, Cargo.toml, etc.
    local old_version=$(echo "$diff" | grep -E '^-.*"version".*:|^-.*version\s*=' | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    local new_version=$(echo "$diff" | grep -E '^\+.*"version".*:|^\+.*version\s*=' | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)

    if [ -n "$old_version" ] && [ -n "$new_version" ]; then
        local old_major=$(echo "$old_version" | cut -d. -f1)
        local new_major=$(echo "$new_version" | cut -d. -f1)

        if [ "$new_major" -gt "$old_major" ]; then
            breaking_detected=true
            breaking_reason="major version bump ($old_version -> $new_version)"
            echo "true|$breaking_reason"
            return
        fi
    fi

    # Check for signature changes (parameter removal/change)
    if echo "$diff" | grep -qE '^-.*\(.*\).*\{' && echo "$diff" | grep -qE '^\+.*\(.*\).*\{'; then
        # Function signatures changed - might be breaking
        # This is a heuristic, not 100% accurate
        local removed_params=$(echo "$diff" | grep -E '^-.*\(.*\)' | grep -oE '\([^)]*\)' | head -1)
        local added_params=$(echo "$diff" | grep -E '^\+.*\(.*\)' | grep -oE '\([^)]*\)' | head -1)

        if [ -n "$removed_params" ] && [ -n "$added_params" ] && [ "$removed_params" != "$added_params" ]; then
            # Count commas to estimate parameter count
            local old_count=$(echo "$removed_params" | tr -cd ',' | wc -c)
            local new_count=$(echo "$added_params" | tr -cd ',' | wc -c)

            if [ "$new_count" -lt "$old_count" ]; then
                breaking_detected=true
                breaking_reason="function signature changed (parameters reduced)"
                echo "true|$breaking_reason"
                return
            fi
        fi
    fi

    echo "false|"
}

# Run breaking change detection
BREAKING_RESULT=$(detect_breaking_changes "$GIT_DIFF")
IS_BREAKING=$(echo "$BREAKING_RESULT" | cut -d'|' -f1)
BREAKING_REASON=$(echo "$BREAKING_RESULT" | cut -d'|' -f2)

# Analyze commit history to learn repository patterns
analyze_commit_history() {
    # Check if we should learn from history
    if [ "$LEARN_FROM_HISTORY" != "true" ]; then
        echo ""
        return
    fi

    # Get last 50 commits (or less if repo is new)
    local commits=$(git log --pretty=format:"%s" -n 50 2>/dev/null)

    if [ -z "$commits" ]; then
        echo ""
        return
    fi

    local total_commits=$(echo "$commits" | wc -l | LC_ALL=C tr -d ' ')

    # Return early if very few commits
    if [ "$total_commits" -lt 5 ]; then
        echo ""
        return
    fi

    # Detect emoji usage
    local emoji_count=$(echo "$commits" | grep -cE '[\x{1F600}-\x{1F64F}\x{1F300}-\x{1F5FF}\x{1F680}-\x{1F6FF}\x{1F1E0}-\x{1F1FF}\x{2600}-\x{26FF}\x{2700}-\x{27BF}]|:[a-z_]+:' 2>/dev/null || echo "0")
    local uses_emoji=false
    if [ "$emoji_count" -gt 0 ]; then
        uses_emoji=true
    fi

    # Detect scope usage (look for parentheses after type)
    local scope_count=$(echo "$commits" | grep -cE '^[a-z]+\([a-z]+\):' 2>/dev/null || echo "0")
    scope_count=$(echo "$scope_count" | LC_ALL=C tr -d '\n' | LC_ALL=C tr -d ' ')
    local uses_scopes=false
    local scope_percentage=0
    if [ "$scope_count" -gt 0 ] 2>/dev/null; then
        uses_scopes=true
        scope_percentage=$((scope_count * 100 / total_commits))
    fi

    # Detect conventional commit types used
    local feat_count=$(echo "$commits" | grep -ciE '^feat[(!:]' 2>/dev/null || echo "0")
    feat_count=$(echo "$feat_count" | LC_ALL=C tr -d '\n' | LC_ALL=C tr -d ' ')
    local fix_count=$(echo "$commits" | grep -ciE '^fix[(!:]' 2>/dev/null || echo "0")
    fix_count=$(echo "$fix_count" | LC_ALL=C tr -d '\n' | LC_ALL=C tr -d ' ')
    local docs_count=$(echo "$commits" | grep -ciE '^docs[(!:]' 2>/dev/null || echo "0")
    docs_count=$(echo "$docs_count" | LC_ALL=C tr -d '\n' | LC_ALL=C tr -d ' ')
    local chore_count=$(echo "$commits" | grep -ciE '^chore[(!:]' 2>/dev/null || echo "0")
    chore_count=$(echo "$chore_count" | LC_ALL=C tr -d '\n' | LC_ALL=C tr -d ' ')
    local refactor_count=$(echo "$commits" | grep -ciE '^refactor[(!:]' 2>/dev/null || echo "0")
    refactor_count=$(echo "$refactor_count" | LC_ALL=C tr -d '\n' | LC_ALL=C tr -d ' ')
    local test_count=$(echo "$commits" | grep -ciE '^test[(!:]' 2>/dev/null || echo "0")
    test_count=$(echo "$test_count" | LC_ALL=C tr -d '\n' | LC_ALL=C tr -d ' ')
    local style_count=$(echo "$commits" | grep -ciE '^style[(!:]' 2>/dev/null || echo "0")
    style_count=$(echo "$style_count" | LC_ALL=C tr -d '\n' | LC_ALL=C tr -d ' ')

    # Detect capitalization preference (first word after type)
    local lowercase_count=$(echo "$commits" | grep -cE '^[a-z]+(\([a-z]+\))?!?: [a-z]' 2>/dev/null || echo "0")
    lowercase_count=$(echo "$lowercase_count" | LC_ALL=C tr -d '\n' | LC_ALL=C tr -d ' ')
    local uppercase_count=$(echo "$commits" | grep -cE '^[a-z]+(\([a-z]+\))?!?: [A-Z]' 2>/dev/null || echo "0")
    uppercase_count=$(echo "$uppercase_count" | LC_ALL=C tr -d '\n' | LC_ALL=C tr -d ' ')
    local prefers_lowercase=true
    if [ "$uppercase_count" -gt "$lowercase_count" ] 2>/dev/null; then
        prefers_lowercase=false
    fi

    # Detect breaking change usage
    local breaking_count=$(echo "$commits" | grep -cE '!:' 2>/dev/null || echo "0")
    breaking_count=$(echo "$breaking_count" | LC_ALL=C tr -d '\n' | LC_ALL=C tr -d ' ')
    local uses_breaking_changes=false
    if [ "$breaking_count" -gt 0 ]; then
        uses_breaking_changes=true
    fi

    # Build history insights
    local insights="Repository commit style (based on last $total_commits commits):"

    # Report scope usage
    if [ "$uses_scopes" = "true" ]; then
        insights="$insights\n- Uses scopes in ${scope_percentage}% of commits"
    else
        insights="$insights\n- Rarely uses scopes"
    fi

    # Report type preferences
    local most_common_type="feat"
    local max_count=$feat_count
    [ "$fix_count" -gt "$max_count" ] 2>/dev/null && most_common_type="fix" && max_count=$fix_count
    [ "$docs_count" -gt "$max_count" ] 2>/dev/null && most_common_type="docs" && max_count=$docs_count
    [ "$chore_count" -gt "$max_count" ] 2>/dev/null && most_common_type="chore" && max_count=$chore_count

    insights="$insights\n- Most common type: $most_common_type"

    # Report capitalization
    if [ "$prefers_lowercase" = "true" ]; then
        insights="$insights\n- Prefers lowercase commit messages"
    else
        insights="$insights\n- Uses capitalized commit messages"
    fi

    # Report emoji usage
    if [ "$uses_emoji" = "true" ]; then
        insights="$insights\n- Sometimes uses emojis"
    fi

    # Report breaking change usage
    if [ "$uses_breaking_changes" = "true" ]; then
        insights="$insights\n- Uses breaking change notation (!) when appropriate"
    fi

    insights="$insights\n\nMatch this repository's style in your commit message."

    echo -e "$insights"
}

# Run history analysis if enabled
HISTORY_INSIGHTS=""
if [ "$LEARN_FROM_HISTORY" = "true" ]; then
    HISTORY_INSIGHTS=$(analyze_commit_history)
fi

# Prepare branch context
BRANCH_CONTEXT="Branch context:
- Branch name: $BRANCH_NAME"

if [ -n "$TICKET_NUMBER" ]; then
    BRANCH_CONTEXT="$BRANCH_CONTEXT
- Ticket number: $TICKET_NUMBER (include this in your commit message)"
fi

if [ -n "$SUGGESTED_TYPE" ]; then
    BRANCH_CONTEXT="$BRANCH_CONTEXT
- Suggested type: $SUGGESTED_TYPE (based on $TYPE_SOURCE)"
fi

if [ "$IS_BREAKING" = "true" ]; then
    BRANCH_CONTEXT="$BRANCH_CONTEXT
- BREAKING CHANGE DETECTED: $BREAKING_REASON"
fi

# Prepare closing instruction
CLOSING_INSTRUCTION="Think: What are all the changes? Then: What's the one-line summary that captures all of them?"
if [ -n "$TICKET_NUMBER" ]; then
    CLOSING_INSTRUCTION="$CLOSING_INSTRUCTION Include ticket $TICKET_NUMBER in the summary."
fi
if [ "$IS_BREAKING" = "true" ]; then
    CLOSING_INSTRUCTION="$CLOSING_INSTRUCTION This is a BREAKING CHANGE - add ! after type and include BREAKING CHANGE footer."
fi

# Prepare prompt with scope and gitmoji options
# Define gitmoji mappings
GITMOJI_INSTRUCTION=""
if [ "$USE_GITMOJI" = "true" ]; then
    GITMOJI_INSTRUCTION="
GITMOJI PREFIXES:
Add the appropriate emoji prefix before the type:
- ‚ú® feat: new feature
- üêõ fix: bug fix
- üìù docs: documentation
- üíÑ style: formatting/styling
- ‚ôªÔ∏è refactor: code refactoring
- ‚úÖ test: adding tests
- üîß chore: tooling/config/maintenance
- üöÄ perf: performance improvement
- üîí security: security fix"
fi

# Build format instruction based on USE_SCOPE and USE_GITMOJI
if [ "$USE_SCOPE" = "true" ] && [ "$USE_GITMOJI" = "true" ]; then
    SCOPE_INSTRUCTION="OUTPUT FORMAT (summary line MUST be first):
<emoji> <type>(<scope>): <concise summary of all changes below>
$GITMOJI_INSTRUCTION

The scope should be a short noun describing what part of the codebase changed:
- auth, api, ui, db, cli, docs, config, tests, deps, etc.
- Choose the most relevant scope based on which files/areas changed
- If changes span multiple areas, pick the primary one

BREAKING CHANGES:
- If this is a breaking change, add ! after type: <emoji> <type>!(<scope>):
- Add a BREAKING CHANGE footer after the bullets explaining the breaking change"
    SCOPE_EXAMPLES="Examples:
- ‚ú® feat(auth): add JWT token validation
- üêõ fix(api): resolve timeout in user endpoint
- ‚ú® feat!(api): redesign authentication flow

BREAKING CHANGE: Legacy /auth/login endpoint removed, use /auth/v2/login instead"
elif [ "$USE_SCOPE" = "true" ]; then
    SCOPE_INSTRUCTION="OUTPUT FORMAT (summary line MUST be first):
<type>(<scope>): <concise summary of all changes below>

The scope should be a short noun describing what part of the codebase changed:
- auth, api, ui, db, cli, docs, config, tests, deps, etc.
- Choose the most relevant scope based on which files/areas changed
- If changes span multiple areas, pick the primary one

BREAKING CHANGES:
- If this is a breaking change, add ! after type: <type>!(<scope>):
- Add a BREAKING CHANGE footer after the bullets explaining the breaking change"
    SCOPE_EXAMPLES="Examples:
- feat(auth): add JWT token validation
- fix(api): resolve timeout in user endpoint
- feat!(api): redesign authentication flow

BREAKING CHANGE: Legacy /auth/login endpoint removed, use /auth/v2/login instead"
elif [ "$USE_GITMOJI" = "true" ]; then
    SCOPE_INSTRUCTION="OUTPUT FORMAT (summary line MUST be first):
<emoji> <type>: <concise summary of all changes below>
$GITMOJI_INSTRUCTION

BREAKING CHANGES:
- If this is a breaking change, add ! after type: <emoji> <type>!:
- Add a BREAKING CHANGE footer after the bullets explaining the breaking change"
    SCOPE_EXAMPLES="Examples:
- ‚ú® feat: add user authentication
- üêõ fix: resolve database connection issue
- ‚ú® feat!: redesign authentication API

BREAKING CHANGE: Legacy /auth/login endpoint removed, use /auth/v2/login instead"
else
    SCOPE_INSTRUCTION="OUTPUT FORMAT (summary line MUST be first):
<type>: <concise summary of all changes below>

BREAKING CHANGES:
- If this is a breaking change, add ! after type: <type>!:
- Add a BREAKING CHANGE footer after the bullets explaining the breaking change"
    SCOPE_EXAMPLES="Examples:
- feat: add user authentication
- fix: resolve database connection issue
- feat!: redesign authentication API

BREAKING CHANGE: Legacy /auth/login endpoint removed, use /auth/v2/login instead"
fi

# Prepare multiple options instruction if requested
MULTIPLE_OPTIONS_INSTRUCTION=""
if [ "$MULTIPLE_OPTIONS" = "true" ]; then
    MULTIPLE_OPTIONS_INSTRUCTION="

IMPORTANT: Generate 3 different variations of the commit message:
1. CONCISE - Minimal details, shorter bullet list
2. DETAILED - More comprehensive, longer bullet list
3. ALTERNATIVE - Different perspective or scope

Separate each variation with the marker: ---OPTION---"
fi

PROMPT="Analyze these git changes and create a commit message.

PROCESS:
1. First, identify all significant changes and list them as bullets
2. Then, synthesize those changes into ONE concise summary line
3. Choose the right type: feat, fix, docs, style, refactor, test, or chore

$SCOPE_INSTRUCTION

- <change 1>
- <change 2>
- <change 3>
- <change 4>

RULES:
- Summary line: max 50 chars, describes the overall purpose
- Use lowercase only (except API, HTTP, JSON, JWT, SQL, ABC-123 tickets)
- Use imperative mood (add/fix not added/fixed)
- The summary should capture the essence of all bullets below it
- Output plain text only, NO markdown formatting, NO code fences

$SCOPE_EXAMPLES

$BRANCH_CONTEXT

$HISTORY_INSIGHTS

Files changed:
$GIT_STATUS

Stats:
$GIT_STATS

Diff sample:
$GIT_DIFF

$CLOSING_INSTRUCTION$MULTIPLE_OPTIONS_INSTRUCTION"

# Escape JSON strings (replace backslash, double quote, newline, carriage return, tab)
escape_json() {
    echo "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\n/\\n/g; s/\r/\\r/g; s/\t/\\t/g' | awk '{printf "%s\\n", $0}' | sed '$ s/\\n$//'
}

# Unescape JSON strings (handle unicode escapes like \u0026)
unescape_json() {
    local text="$1"

    # First, decode unicode escapes (\uXXXX)
    # This handles common cases like \u0026 (&), \u003c (<), \u003e (>)
    while [[ "$text" =~ \\u([0-9a-fA-F]{4}) ]]; do
        local hex="${BASH_REMATCH[1]}"
        local dec=$((16#$hex))
        # Use printf to convert to actual character
        local char=$(printf "\\$(printf '%03o' "$dec")")
        text="${text/\\u$hex/$char}"
    done

    # Then handle standard JSON escapes
    text="${text//\\\\/\\}"    # \\ -> \
    text="${text//\\\"/\"}"    # \" -> "

    echo "$text"
}

# Enforce lowercase on commit message while preserving acronyms and ticket numbers
enforce_lowercase() {
    local message="$1"
    local temp_message="$message"

    # First, protect ticket numbers by replacing them with placeholders
    # Pattern: ABC-123, JIRA-456, etc.
    local ticket_counter=0
    local tickets_file=$(mktemp)

    # Find all ticket numbers and store them
    echo "$message" | grep -oE '[A-Z][A-Z0-9]+-[0-9]+' > "$tickets_file"

    # Replace tickets with placeholders
    while IFS= read -r ticket; do
        if [ -n "$ticket" ]; then
            temp_message=$(echo "$temp_message" | sed "s/$ticket/__TICKET${ticket_counter}__/g")
            ((ticket_counter++))
        fi
    done < "$tickets_file"

    # Convert entire message to lowercase
    temp_message=$(echo "$temp_message" | tr '[:upper:]' '[:lower:]')

    # Restore ticket numbers
    ticket_counter=0
    while IFS= read -r ticket; do
        if [ -n "$ticket" ]; then
            temp_message=$(echo "$temp_message" | sed "s/__ticket${ticket_counter}__/$ticket/g")
            ((ticket_counter++))
        fi
    done < "$tickets_file"

    rm -f "$tickets_file"

    # Restore common acronyms (case-insensitive search and replace)
    local acronyms="API HTTP HTTPS JSON XML SQL JWT OAuth REST CLI UI UX CSS HTML JS TS URL URI PDF CSV IDE SDK CI CD AWS GCP DNS SSL TLS SSH FTP SMTP TCP UDP IP DOM npm NPM README TODO FIXME"

    for acronym in $acronyms; do
        local lowercase_acronym=$(echo "$acronym" | tr '[:upper:]' '[:lower:]')
        # Use word boundaries to avoid partial matches
        temp_message=$(echo "$temp_message" | sed "s/\b$lowercase_acronym\b/$acronym/g")
    done

    echo "$temp_message"
}

# Calculate cost for API usage
calculate_cost() {
    local provider="$1"
    local model="$2"
    local input_tokens="$3"
    local output_tokens="$4"

    # Return early if no token data
    if [ -z "$input_tokens" ] || [ -z "$output_tokens" ]; then
        return
    fi

    local input_cost=0
    local output_cost=0
    local currency="USD"

    # Pricing per 1M tokens (as of early 2025)
    case "$provider" in
        anthropic)
            case "$model" in
                claude-3-5-sonnet-20241022|claude-3-5-sonnet-latest)
                    input_cost=3.00    # $3 per MTok
                    output_cost=15.00  # $15 per MTok
                    ;;
                claude-3-opus-20240229)
                    input_cost=15.00   # $15 per MTok
                    output_cost=75.00  # $75 per MTok
                    ;;
                claude-3-haiku-20240307)
                    input_cost=0.25    # $0.25 per MTok
                    output_cost=1.25   # $1.25 per MTok
                    ;;
                *)
                    # Default to Sonnet pricing
                    input_cost=3.00
                    output_cost=15.00
                    ;;
            esac
            ;;
        openai)
            case "$model" in
                gpt-4o)
                    input_cost=2.50    # $2.50 per MTok
                    output_cost=10.00  # $10 per MTok
                    ;;
                gpt-4o-mini)
                    input_cost=0.15    # $0.15 per MTok
                    output_cost=0.60   # $0.60 per MTok
                    ;;
                gpt-4-turbo|gpt-4-turbo-preview)
                    input_cost=10.00   # $10 per MTok
                    output_cost=30.00  # $30 per MTok
                    ;;
                gpt-4)
                    input_cost=30.00   # $30 per MTok
                    output_cost=60.00  # $60 per MTok
                    ;;
                *)
                    # Default to gpt-4o-mini pricing
                    input_cost=0.15
                    output_cost=0.60
                    ;;
            esac
            ;;
    esac

    # Calculate costs (tokens / 1,000,000 * price per million)
    # Using bc for floating point, or awk if bc not available
    if command -v bc >/dev/null 2>&1; then
        local input_cost_calc=$(echo "scale=6; $input_tokens / 1000000 * $input_cost" | bc)
        local output_cost_calc=$(echo "scale=6; $output_tokens / 1000000 * $output_cost" | bc)
        local total_cost=$(echo "scale=6; $input_cost_calc + $output_cost_calc" | bc)
    else
        # Fallback to awk if bc not available
        local input_cost_calc=$(awk "BEGIN {printf \"%.6f\", $input_tokens / 1000000 * $input_cost}")
        local output_cost_calc=$(awk "BEGIN {printf \"%.6f\", $output_tokens / 1000000 * $output_cost}")
        local total_cost=$(awk "BEGIN {printf \"%.6f\", $input_cost_calc + $output_cost_calc}")
    fi

    # Format for display (remove trailing zeros)
    local total_cost_display=$(echo "$total_cost" | sed 's/0*$//' | sed 's/\.$//')

    # If cost is very small, show more precision
    if [ $(echo "$total_cost < 0.0001" | bc 2>/dev/null || echo 0) -eq 1 ]; then
        total_cost_display=$(printf "%.6f" "$total_cost" | sed 's/0*$//' | sed 's/\.$//')
    else
        total_cost_display=$(printf "%.4f" "$total_cost" | sed 's/0*$//' | sed 's/\.$//')
    fi

    # Display token usage and cost
    local total_tokens=$((input_tokens + output_tokens))
    echo "üí∞ Token usage: ${total_tokens} tokens (${input_tokens} input + ${output_tokens} output)"
    echo "üí∞ Estimated cost: \$$total_cost_display $currency"

    # Track cumulative cost
    track_cumulative_cost "$total_cost"
}

# Track cumulative costs
track_cumulative_cost() {
    local cost="$1"
    local cost_file="/tmp/gh-commit-ai-costs-$(date +%Y%m%d)"

    # Append to daily cost file
    echo "$cost" >> "$cost_file"

    # Calculate cumulative total for today
    if command -v bc >/dev/null 2>&1; then
        local cumulative=$(awk '{sum+=$1} END {printf "%.6f", sum}' "$cost_file")
    else
        local cumulative=$(awk '{sum+=$1} END {printf "%.6f", sum}' "$cost_file")
    fi

    # Format for display
    local cumulative_display=$(printf "%.4f" "$cumulative" | sed 's/0*$//' | sed 's/\.$//')

    echo "üí∞ Today's total: \$$cumulative_display USD"
}

# Strip ANSI color codes from text
strip_ansi_codes() {
    local text="$1"
    # Remove ANSI escape sequences
    echo "$text" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/\\033\[[0-9;]*m//g'
}

# Convert literal \n to actual newlines for better display in GitHub
convert_newlines() {
    local text="$1"
    # Use printf %b to interpret backslash escapes
    printf "%b" "$text"
}

# Parse multiple commit message options from AI response
parse_multiple_options() {
    local response="$1"

    # Split by ---OPTION--- marker
    # Store options in a temporary file
    local options_file=$(mktemp)
    echo "$response" | awk 'BEGIN{n=1} /---OPTION---/{n++; next} {print > "/tmp/option_"n".txt"}'

    # If no markers found, treat as single option
    if [ ! -f "/tmp/option_1.txt" ]; then
        echo "$response" > "/tmp/option_1.txt"
        echo "1"
        return
    fi

    # Count how many options we have
    local count=0
    for f in /tmp/option_*.txt; do
        [ -f "$f" ] && count=$((count + 1))
    done

    echo "$count"
}

# Display multiple options for user selection
display_options() {
    local num_options="$1"

    echo -e "Generated ${num_options} commit message options:\n"

    for i in $(seq 1 $num_options); do
        local option_file="/tmp/option_${i}.txt"
        if [ -f "$option_file" ]; then
            local option_content=$(cat "$option_file" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            echo -e "Option $i:"
            echo -e "$option_content\n"
        fi
    done
}

# Get user's option selection
select_option() {
    local num_options="$1"

    while true; do
        echo -n "Select option (1-${num_options}), or 'n' to cancel: "
        read -n 1 -r
        echo

        if [[ $REPLY =~ ^[Nn]$ ]]; then
            echo "cancelled"
            return
        fi

        if [[ $REPLY =~ ^[0-9]+$ ]] && [ "$REPLY" -ge 1 ] && [ "$REPLY" -le "$num_options" ]; then
            echo "$REPLY"
            return
        fi

        echo -e "${RED}‚ùå Invalid selection. Please enter 1-${num_options} or 'n' to cancel."
    done
}

# Call Ollama API
call_ollama() {
    local prompt="$1"

    local model_escaped=$(escape_json "$OLLAMA_MODEL")
    local prompt_escaped=$(escape_json "$prompt")
    local json_payload=$(printf '{"model":"%s","prompt":"%s","stream":false}' "$model_escaped" "$prompt_escaped")

    if [ "$VERBOSE" = "true" ]; then
        echo "[Verbose] API Endpoint:${NC} $OLLAMA_HOST/api/generate"
        echo "[Verbose] Request payload:"
        echo "$json_payload" | jq '.' 2>/dev/null || echo "$json_payload"
        echo ""
    fi

    # Run API call in background with spinner
    local temp_response="/tmp/gh-commit-ai-response-$$"
    (
        curl -s -X POST "$OLLAMA_HOST/api/generate" \
            -H "Content-Type: application/json" \
            -d "$json_payload" > "$temp_response"
    ) &
    local api_pid=$!

    show_spinner "$api_pid" "Thinking"
    wait "$api_pid"

    local response=$(cat "$temp_response")
    rm -f "$temp_response"

    if [ "$VERBOSE" = "true" ]; then
        echo "[Verbose] Response:"
        echo "$response" | jq '.' 2>/dev/null || echo "$response"
        echo ""
    fi

    # Check for errors
    if echo "$response" | grep -q '"error"'; then
        local error_msg=$(echo "$response" | grep -o '"error":"[^"]*"' | sed 's/"error":"//;s/"$//')
        echo -e "${RED}Error from Ollama: $error_msg" >&2
        echo "Tip: Make sure Ollama is running (ollama serve) and the model is available (ollama list)" >&2
        return 1
    fi

    # Extract commit message from response
    # Use awk to properly extract JSON string value (handles escaped quotes)
    local raw_message=$(echo "$response" | awk -F'"response":"' '{
        if (NF > 1) {
            str = $2
            result = ""
            escaped = 0
            for (i = 1; i <= length(str); i++) {
                c = substr(str, i, 1)
                if (escaped) {
                    result = result c
                    escaped = 0
                } else if (c == "\\") {
                    result = result c
                    escaped = 1
                } else if (c == "\"") {
                    break
                } else {
                    result = result c
                }
            }
            print result
        }
    }')
    unescape_json "$raw_message"
}

# Call Anthropic API
call_anthropic() {
    local prompt="$1"

    if [ -z "$ANTHROPIC_API_KEY" ]; then
        echo -e "${RED}Error: ANTHROPIC_API_KEY is not set" >&2
        echo "Tip: Set your API key with: export ANTHROPIC_API_KEY=\"sk-ant-...\"" >&2
        echo "Get your API key from: https://console.anthropic.com/settings/keys" >&2
        exit 1
    fi

    local prompt_escaped=$(escape_json "$prompt")
    local json_payload=$(printf '{"model":"%s","max_tokens":1024,"messages":[{"role":"user","content":"%s"}]}' "$ANTHROPIC_MODEL" "$prompt_escaped")

    if [ "$VERBOSE" = "true" ]; then
        echo "[Verbose] API Endpoint:${NC} https://api.anthropic.com/v1/messages"
        echo "[Verbose] Model:${NC} $ANTHROPIC_MODEL"
        echo "[Verbose] Request payload:"
        echo "$json_payload" | jq '.' 2>/dev/null || echo "$json_payload"
        echo ""
    fi

    # Run API call in background with spinner
    local temp_response="/tmp/gh-commit-ai-response-$$"
    (
        curl -s -X POST "https://api.anthropic.com/v1/messages" \
            -H "Content-Type: application/json" \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -d "$json_payload" > "$temp_response"
    ) &
    local api_pid=$!

    show_spinner "$api_pid" "Thinking"
    wait "$api_pid"

    local response=$(cat "$temp_response")
    rm -f "$temp_response"

    if [ "$VERBOSE" = "true" ]; then
        echo "[Verbose] Response:"
        echo "$response" | jq '.' 2>/dev/null || echo "$response"
        echo ""
    fi

    # Check for errors
    if echo "$response" | grep -q '"error"'; then
        local error_type=$(echo "$response" | grep -o '"type":"[^"]*"' | head -1 | sed 's/"type":"//;s/"$//')
        local error_msg=$(echo "$response" | grep -o '"message":"[^"]*"' | head -1 | sed 's/"message":"//;s/"$//')
        echo -e "${RED}Error from Anthropic ($error_type): $error_msg" >&2

        if [[ "$error_type" == *"authentication"* ]] || [[ "$error_msg" == *"API key"* ]]; then
            echo "Tip: Check your API key is valid and has credits" >&2
        elif [[ "$error_type" == *"rate_limit"* ]]; then
            echo "Tip: You've hit the rate limit. Wait a moment and try again" >&2
        fi
        return 1
    fi

    # Extract token usage (global variables for cost tracking)
    INPUT_TOKENS=$(echo "$response" | grep -o '"input_tokens":[0-9]*' | head -1 | grep -o '[0-9]*')
    OUTPUT_TOKENS=$(echo "$response" | grep -o '"output_tokens":[0-9]*' | head -1 | grep -o '[0-9]*')

    # Extract commit message from response
    # Anthropic returns: {"content":[{"text":"...","type":"text"}],...}
    # Use awk to properly extract JSON string value (handles escaped quotes)
    local raw_message=$(echo "$response" | awk -F'"text":"' '{
        if (NF > 1) {
            str = $2
            result = ""
            escaped = 0
            for (i = 1; i <= length(str); i++) {
                c = substr(str, i, 1)
                if (escaped) {
                    result = result c
                    escaped = 0
                } else if (c == "\\") {
                    result = result c
                    escaped = 1
                } else if (c == "\"") {
                    break
                } else {
                    result = result c
                }
            }
            print result
            exit
        }
    }')
    unescape_json "$raw_message"
}

# Call OpenAI API
call_openai() {
    local prompt="$1"

    if [ -z "$OPENAI_API_KEY" ]; then
        echo -e "${RED}Error: OPENAI_API_KEY is not set" >&2
        echo "Tip: Set your API key with: export OPENAI_API_KEY=\"sk-proj-...\"" >&2
        echo "Get your API key from: https://platform.openai.com/api-keys" >&2
        exit 1
    fi

    local prompt_escaped=$(escape_json "$prompt")
    local json_payload=$(printf '{"model":"%s","messages":[{"role":"user","content":"%s"}],"temperature":0.7}' "$OPENAI_MODEL" "$prompt_escaped")

    if [ "$VERBOSE" = "true" ]; then
        echo "[Verbose] API Endpoint:${NC} https://api.openai.com/v1/chat/completions"
        echo "[Verbose] Model:${NC} $OPENAI_MODEL"
        echo "[Verbose] Request payload:"
        echo "$json_payload" | jq '.' 2>/dev/null || echo "$json_payload"
        echo ""
    fi

    # Run API call in background with spinner
    local temp_response="/tmp/gh-commit-ai-response-$$"
    (
        curl -s -X POST "https://api.openai.com/v1/chat/completions" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "$json_payload" > "$temp_response"
    ) &
    local api_pid=$!

    show_spinner "$api_pid" "Thinking"
    wait "$api_pid"

    local response=$(cat "$temp_response")
    rm -f "$temp_response"

    if [ "$VERBOSE" = "true" ]; then
        echo "[Verbose] Response:"
        echo "$response" | jq '.' 2>/dev/null || echo "$response"
        echo ""
    fi

    # Check for errors
    if echo "$response" | grep -q '"error"'; then
        local error_type=$(echo "$response" | grep -o '"type":"[^"]*"' | head -1 | sed 's/"type":"//;s/"$//')
        local error_msg=$(echo "$response" | grep -o '"message":"[^"]*"' | head -1 | sed 's/"message":"//;s/"$//')
        local error_code=$(echo "$response" | grep -o '"code":"[^"]*"' | head -1 | sed 's/"code":"//;s/"$//')

        echo -e "${RED}Error from OpenAI" >&2
        [ -n "$error_code" ] && echo -e "${RED}Code: $error_code" >&2
        [ -n "$error_type" ] && echo -e "${RED}Type: $error_type" >&2
        [ -n "$error_msg" ] && echo -e "${RED}Message: $error_msg" >&2

        if [[ "$error_code" == *"invalid_api_key"* ]] || [[ "$error_msg" == *"API key"* ]]; then
            echo "Tip: Check your API key is valid and has credits" >&2
        elif [[ "$error_code" == *"rate_limit"* ]]; then
            echo "Tip: You've hit the rate limit. Wait a moment and try again" >&2
        elif [[ "$error_code" == *"model_not_found"* ]]; then
            echo "Tip: The model '$OPENAI_MODEL' doesn't exist or you don't have access" >&2
        fi
        return 1
    fi

    # Extract token usage (global variables for cost tracking)
    INPUT_TOKENS=$(echo "$response" | grep -o '"prompt_tokens":[0-9]*' | head -1 | grep -o '[0-9]*')
    OUTPUT_TOKENS=$(echo "$response" | grep -o '"completion_tokens":[0-9]*' | head -1 | grep -o '[0-9]*')

    # Extract commit message from response
    # OpenAI returns: {"choices":[{"message":{"content":"..."},...}],...}
    # Use awk to properly extract JSON string value (handles escaped quotes)
    local raw_message=$(echo "$response" | awk -F'"content":"' '{
        if (NF > 1) {
            str = $2
            result = ""
            escaped = 0
            for (i = 1; i <= length(str); i++) {
                c = substr(str, i, 1)
                if (escaped) {
                    result = result c
                    escaped = 0
                } else if (c == "\\") {
                    result = result c
                    escaped = 1
                } else if (c == "\"") {
                    break
                } else {
                    result = result c
                }
            }
            print result
            exit
        }
    }')
    unescape_json "$raw_message"
}

# Call the appropriate AI provider
case "$AI_PROVIDER" in
    ollama)
        COMMIT_MSG=$(call_ollama "$PROMPT")
        ;;
    anthropic)
        COMMIT_MSG=$(call_anthropic "$PROMPT")
        ;;
    openai)
        COMMIT_MSG=$(call_openai "$PROMPT")
        ;;
    *)
        echo -e "${RED}Error: Unknown AI provider '$AI_PROVIDER'"
        echo "Supported providers: ollama, anthropic, openai"
        exit 1
        ;;
esac

# Strip markdown code fences if AI wrapped the response
# Remove lines that are just code fences (```diff, ```markdown, ```, etc.)
COMMIT_MSG=$(echo "$COMMIT_MSG" | awk '
    /^```[a-zA-Z]*$/ { next }  # Skip opening fence line
    /^```$/ { next }            # Skip closing fence line
    { print }
')

if [ -z "$COMMIT_MSG" ] || [ "$COMMIT_MSG" = "null" ]; then
    echo -e "${RED}Error: Failed to generate commit message"
    echo "Please check your API configuration and try again."
    exit 1
fi

# Handle multiple options mode
if [ "$MULTIPLE_OPTIONS" = "true" ]; then
    # Clean up any existing temp files
    rm -f /tmp/option_*.txt 2>/dev/null

    # Parse options from response
    num_options=$(parse_multiple_options "$COMMIT_MSG")

    # Enforce lowercase on each option (unless disabled)
    if [ "$NO_LOWERCASE" != "true" ]; then
        for i in $(seq 1 $num_options); do
            if [ -f "/tmp/option_${i}.txt" ]; then
                local option_content=$(cat "/tmp/option_${i}.txt")
                local lowercased=$(enforce_lowercase "$option_content")
                echo "$lowercased" > "/tmp/option_${i}.txt"
            fi
        done
    fi

    # Display all options
    echo ""
    display_options "$num_options"

    # Show cost information for paid APIs
    if [ "$AI_PROVIDER" = "anthropic" ]; then
        calculate_cost "anthropic" "$ANTHROPIC_MODEL" "$INPUT_TOKENS" "$OUTPUT_TOKENS"
        echo ""
    elif [ "$AI_PROVIDER" = "openai" ]; then
        calculate_cost "openai" "$OPENAI_MODEL" "$INPUT_TOKENS" "$OUTPUT_TOKENS"
        echo ""
    fi

    # Get user selection
    selected=$(select_option "$num_options")

    if [ "$selected" = "cancelled" ]; then
        echo "Commit cancelled"
        rm -f /tmp/option_*.txt 2>/dev/null
        exit 0
    fi

    # Load selected option
    COMMIT_MSG=$(cat "/tmp/option_${selected}.txt")
    rm -f /tmp/option_*.txt 2>/dev/null

    # Save to message history
    save_message_history "$COMMIT_MSG"

    # Show selected message
    echo -e "\nSelected commit message:"
    echo "$COMMIT_MSG"
    echo ""
else
    # Single message mode - enforce lowercase (unless disabled)
    if [ "$NO_LOWERCASE" != "true" ]; then
        COMMIT_MSG=$(enforce_lowercase "$COMMIT_MSG")
    fi

    # Save to message history
    save_message_history "$COMMIT_MSG"

    # Show the generated commit message with proper newlines
    echo -e "\n‚úì Generated commit message:"
    DISPLAY_MSG=$(convert_newlines "$COMMIT_MSG")
    printf "%s\n\n" "$DISPLAY_MSG"

    # Show cost information for paid APIs
    if [ "$AI_PROVIDER" = "anthropic" ]; then
        calculate_cost "anthropic" "$ANTHROPIC_MODEL" "$INPUT_TOKENS" "$OUTPUT_TOKENS"
        echo ""
    elif [ "$AI_PROVIDER" = "openai" ]; then
        calculate_cost "openai" "$OPENAI_MODEL" "$INPUT_TOKENS" "$OUTPUT_TOKENS"
        echo ""
    fi
fi

# Handle preview mode - just show and exit
if [ "$PREVIEW" = true ]; then
    exit 0
fi

# Handle dry-run mode - ask if user wants to save to file
if [ "$DRY_RUN" = true ]; then
    read -p "Save to file? (y/n): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        COMMIT_FILE=".git/COMMIT_MSG_$(date +%s)"
        # Strip ANSI codes and convert newlines before saving
        CLEAN_MSG=$(strip_ansi_codes "$COMMIT_MSG")
        CLEAN_MSG=$(convert_newlines "$CLEAN_MSG")
        printf "%s" "$CLEAN_MSG" > "$COMMIT_FILE"
        echo "‚úì Saved to $COMMIT_FILE"
    else
        echo "Message not saved"
    fi
    exit 0
fi

# Ask for confirmation
while true; do
    echo -n "Use this commit message? (y/n/e to edit): "
    read -n 1 -r
    echo

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Strip any ANSI color codes before committing
        CLEAN_MSG=$(strip_ansi_codes "$COMMIT_MSG")
        # Convert literal \n to actual newlines
        CLEAN_MSG=$(convert_newlines "$CLEAN_MSG")

        if [ "$AMEND" = true ]; then
            # Amend the last commit with new message using HEREDOC for proper newline handling
            git commit --amend -m "$(cat <<EOF
$CLEAN_MSG
EOF
)"
            echo "‚úì Amended commit successfully!"
        else
            # Stage all changes if nothing is staged
            if git diff --cached --quiet; then
                echo "Staging all changes"
                git add -A
            fi

            # Commit with the generated message using HEREDOC for proper newline handling
            git commit -m "$(cat <<EOF
$CLEAN_MSG
EOF
)"
            echo "‚úì Committed successfully!"
        fi
        break
    elif [[ $REPLY =~ ^[Ee]$ ]]; then
        # Strip any ANSI color codes before editing
        CLEAN_MSG=$(strip_ansi_codes "$COMMIT_MSG")
        # Convert literal \n to actual newlines
        CLEAN_MSG=$(convert_newlines "$CLEAN_MSG")

        # Allow user to edit the message in editor using HEREDOC for proper newline handling
        if [ "$AMEND" = true ]; then
            git commit --amend -e -m "$(cat <<EOF
$CLEAN_MSG
EOF
)"
            echo "‚úì Amended commit with edited message!"
        else
            git commit -e -m "$(cat <<EOF
$CLEAN_MSG
EOF
)"
            echo "‚úì Committed with edited message!"
        fi
        break
    else
        echo "Commit cancelled"
        exit 0
    fi
done
